<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="STYLESHEET" href="../book.css" charset="ISO-8859-1" type="text/css">
<title>Eclipse 3.0 Porting Guide</title>
</head>

<body>

<h1>Eclipse 3.0 Porting Guide</h1>
<p>Draft for 3.0 RC3<br>
Last revised June 18, 2004</p>
<p>This porting guide describes how to port existing 2.1 plug-ins to 3.0. It is
organized as follows:</p>
<ul>
  <li><a href="#Required Changes for 3.0">Required Changes</a></li>
  <li><a href="#Recommended Changes for 3.0">Recommended Changes</a></li>
  <li><a href="#PDE Plug-in Migration Tool">PDE Plug-in Migration Tool</a></li>
  <li><a href="#General Information on Compatibility">General Information on
    Compatibility</a></li>
</ul>
<h2><a name="Required Changes for 3.0">Required Changes for 3.0</a></h2>
<p>This section describes changes that impact existing plug-ins. If your plug-in
is affected, you will have to change your plug-in in order to get it to work
properly with Eclipse 3.0.</p>
<h3>Plug-in manifest version</h3>
<p>The header of the manifest files for plug-ins (and plug-in fragments) has
changed to include a new line which identifies the appropriate plug-in manifest
version. Prior to 3.0, plug-ins did not carry one of these &lt;?eclipse ...?&gt;
lines; after 3.0, they must always have one. This change is to allow the Eclipse
runtime to reliably recognize pre-3.0 plug-ins that have not been ported to 3.0,
so that it can automatically provide greater binary compatibility for such
plug-ins. This is the general form of the plugin.xml file (fragment.xml is
similar):</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>
<u>&lt;?eclipse version=&quot;3.0&quot;?&gt;<br>
</u>&lt;plugin ...&gt;<br>
&nbsp;&nbsp;&nbsp; ...<br>
&lt;/plugin&gt;</code>
<p>When porting to 3.0, add the indicated line to the manifest of existing
plug-ins and plug-in fragments. (The PDE plug-in migration tool adds this line.)</p>
<p>If you do add this directive to a plugin.xml (manually or using PDE), the
file must also be updated to explicitly list the plug-ins on which it depends.
For example, prior to Eclipse 3.0 dependencies on org.eclipse.core.runtime and
org.eclipse.core.boot were implicit. With 3.0, org.eclipse.core.boot is no
longer needed and developers must choose org.eclipse.core.runtime or
org.eclipse.core.runtime.compatibility (or neither) as appropriate.</p>
<p>&nbsp;</p>
<h3>Restructuring of org.eclipse.ui plug-in</h3>
<p>The org.eclipse.ui plug-in, which used to be the main Platform UI plug-in,
now provides just the API and extension points for the generic (i.e.,
non-IDE-specific) workbench. Optional and IDE-specific API and extension points
have moved to other plug-ins.</p>
<p>The impact of this change is two-fold: (1) the moved org.eclipse.ui extension
points have new extension point ids; and (2) the list of required plug-ins has
changed.</p>
<p>N.B. The Eclipse 3.0 runtime automatically detects pre-3.0 plug-ins (by the
absence of the aforementioned &lt;?eclipse...?&gt; line in the plug-in manifest)
and automatically compensates for these extension point and plug-in dependency
changes. This should be viewed as a stopgap measure that increases the
likelihood that an existing plug-in that depends on org.eclipse.ui will work in
3.0. However, when porting the existing plug-in to 3.0, the plug-in's manifest
needs to be updated to reflect the new structure of the Eclipse UI plug-ins.</p>
<p>The org.eclipse.ui extension points in the following table have moved to
different plug-ins, causing their extension point ids to change. If an existing
plug-in contributes an extension to the moved extension points, then the
reference in the &quot;point&quot; attribute of the &lt;extension&gt; element in
the plug-in manifest file must be changed to refer to the corresponding new ones
extension point id. (The PDE plug-in migration tool makes these fix-ups.)</p>
<table border="1" width="80%">
  <tr>
    <td width="50%">
      <p align="center"><b>Old extension point id</b></td>
    <td width="50%">
      <p align="center"><b>New extension point id</b></td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.markerHelp</td>
    <td width="50%">org.eclipse.ui.<i>ide</i>.markerHelp</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.markerImageProviders</td>
    <td width="50%">org.eclipse.ui.<i>ide</i>.markerImageProviders</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.markerResolution</td>
    <td width="50%">org.eclipse.ui.<i>ide</i>.markerResolution</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.projectNatureImages</td>
    <td width="50%">org.eclipse.ui.<i>ide</i>.projectNatureImages</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.resourceFilters</td>
    <td width="50%">org.eclipse.ui.<i>ide</i>.resourceFilters</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.markerUpdaters</td>
    <td width="50%">org.eclipse.ui.<i>editors</i>.markerUpdaters</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.documentProviders</td>
    <td width="50%">org.eclipse.ui.<i>editors</i>.documentProviders</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.workbench.texteditor.<br>
      markerAnnotationSpecification</td>
    <td width="50%">org.eclipse.ui.<i>editors</i>.markerAnnotationSpecification</td>
  </tr>
</table>
<p>The following table lists the API packages formerly provided by the
org.eclipse.ui plug-in that have been moved to different plug-ins. (The names of
the API packages, classes, fields, and methods did not change.) In some cases,
the API packages are now split across more than one plug-in. Since the API
classes visible to any given plug-in are determined by that plug-in's list of
required plug-ins, these changes may require adjusting
&quot;&lt;requires&gt;&quot; elements in an existing plug-in's manifest to
regain access to API class.</p>
<p>This change only affects plug-ins that depend on the org.eclipse.ui plug-in
(that is, includes &lt;import plugin=&quot;org.eclipse.ui&quot;/&gt; in the
&lt;requires&gt; section of the plug-in manifest); all other plug-ins are
unaffected. If it is affected, you <i>may</i> need to change the &lt;import&gt;
element, or add additional &lt;import&gt; elements, so that all the API classes
your plug-in needs are in scope. We strongly recommend that plug-ins only state
dependencies on the plug-ins that they actually use. Including unnecessary
dependencies reduces runtime performance because the Java class loader must
search for classes in all dependents. (The PDE plug-in migration tool will fix
up the dependencies, and help to determine a minimal set.)</p>
<table border="1" width="80%">
  <tr>
    <td width="33%">
      <p align="center"><b>API package</b></td>
    <td width="33%">
      <p align="center"><b>2.1 plug-in</b></td>
    <td width="34%">
      <p align="center"><b>Corresponding 3.0 plug-in(s)</b></td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.jface.text.*</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.jface.text</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.text.*</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.jface.text</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui, org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.actions</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui, org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.dialogs</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui, org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.editors.*</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.editor</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.model</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui, org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.part</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui, org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.texteditor</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.workbench.texteditor, org.eclipse.ui.editors</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.texteditor.*</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.workbench.texteditor</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.bookmarkexplorer</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.contentoutline</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.views</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.markers</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.navigator</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.properties</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.views</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.views.tasklist</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.wizards.datatransfer</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
  <tr>
    <td width="33%">org.eclipse.ui.wizards.newresource</td>
    <td width="33%">org.eclipse.ui</td>
    <td width="34%">org.eclipse.ui.ide</td>
  </tr>
</table>
<h3>Changes to API classes and interfaces (by package)</h3>
<h4>IWorkbench (package org.eclipse.ui)</h4>
<ul>
  <li>The following method was removed from this interface because it was
    IDE-specific:
    <ul>
      <li>public IMarkerHelpRegistry getMarkerHelpRegistry()</li>
    </ul>
  </li>
  <li>Clients of getMarkerHelpRegistry() should instead call the public static
    method IDE.getMarkerHelpRegistry() declared in the org.eclipse.ui.ide
    package (org.eclipse.ui.ide plug-in).</li>
</ul>
<h4>IWorkbenchPage (package org.eclipse.ui)</h4>
<ul>
  <li>The following methods were removed from this interface because they were
    IDE-specific:
    <ul>
      <li>public IEditorPart openEditor(IFile input)</li>
      <li>public IEditorPart openEditor(IFile input, String editorID)</li>
      <li>public IEditorPart openEditor(IFile input, String editorID, boolean
        activate)</li>
      <li>public IEditorPart openEditor(IMarker marker)</li>
      <li>public IEditorPart openEditor(IMarker marker, boolean activate)</li>
      <li>public void openSystemEditor(IFile input)</li>
    </ul>
  </li>
  <li>Clients of openEditor(IFile,*) methods should convert the IFile to an
    IEditorInput using new FileEditorInput(IFile) and then call one of the
    openEditor(IEditorInput,*) methods. Thus
    <ul>
      <li>rewrite page.openEditor(file,editorID) as openEditor(new
        FileEditorInput(file), editorID)</li>
      <li>rewrite page.openEditor(file,editorID, activate) as openEditor(new
        FileEditorInput(file), editorID, activate)</li>
    </ul>
  </li>
  <li>Clients of openEditor(IFile) method should call
    org.eclipse.ui.ide.IDE.openEditor(IWorkbenchPage, IFile, boolean)
    <ul>
      <li>rewrite openEditor(file) as IDE.openEditor(page, file, true)</li>
    </ul>
  </li>
  <li>Clients of openEditor(IMarker, ...) methods should call
    org.eclipse.ui.ide.IDE.openEditor(IWorkbenchPage, IMarker, boolean)
    <ul>
      <li>rewrite page.openEditor(marker) as IDE.openEditor(page, marker, true)</li>
      <li>rewrite page.openEditor(IMarker, activate) as IDE.openEditor(page,
        marker, activate)</li>
      <li>editors that can position themselves based on IMarker information
        should implement or adapt to org.eclipse.ui.ide.IMarkerEditorPositioner</li>
    </ul>
  </li>
  <li>Clients of openSystemEditor(IFile) method should convert the IFile to an
    IEditorInput using new FileEditorInput(IFile) and then call the
    openEditor(IEditorInput,String) method. Thus
    <ul>
      <li>rewrite page.openSystemEditor(file) as page.openEditor(new
        FileEditorInput(file), IEditorRegistry.SYSTEM_EXTERNAL_EDITOR_ID)</li>
      <li>Note: clients using editor id
        IEditorRegistry.SYSTEM_EXTERNAL_EDITOR_ID must pass an editor input
        which implements org.eclipse.ui.IPathEditorInput (which FileEditorInput
        does).</li>
    </ul>
  </li>
  <li>N.B. Eclipse 3.0 includes a binary runtime compatibility mechanism that
    ensures existing 2.1 plug-in binaries using any of the deleted openEditor
    and openSystemEditor methods continue to work as in 2.1 in spite of this
    breaking API change. (These deleted methods are &quot;added back&quot; by
    the org.eclipse.ui.workbench.compatibility fragment.)</li>
</ul>
<h4>IEditorPart (package org.eclipse.ui)</h4>
<ul>
  <li>The following method was removed from this interface because it was
    resource-specific:
    <ul>
      <li>public void gotoMarker(IMarker marker)</li>
    </ul>
  </li>
  <li>Clients that called this method should instead test if the editor part
    implements or adapts to org.eclipse.ui.ide.IGotoMarker and if so, call
    gotoMarker(IMarker). The IDE class has a convenience method for doing so:<br>
    <code>IDE.gotoMarker(editor, marker);</code></li>
  <li>Clients that implement an editor that can position itself based on IMarker
    information should implement or adapt to org.eclipse.ui.ide.IGotoMarker.</li>
  <li>Since IGotoMarker's only method is gotoMarker(IMarker), existing editor
    implementations can adapt to this change simply by adding <code>extends
    IGotoMarker</code> to the class definition.</li>
</ul>
<h4>EditorPart (package org.eclipse.ui.part)</h4>
<ul>
  <li>The following former IEditorPart method was removed from this class
    because it was resource-specific:
    <ul>
      <li>public void gotoMarker(IMarker marker)</li>
    </ul>
  </li>
  <li>See above instructions for IEditorPart.gotoMarker.</li>
</ul>
<h4>MultiEditor (package org.eclipse.ui.part)</h4>
<ul>
  <li>The following former IEditorPart method was removed from this class
    because it was resource-specific:
    <ul>
      <li>public void gotoMarker(IMarker marker)</li>
    </ul>
  </li>
  <li>See above instructions for IEditorPart.gotoMarker.</li>
</ul>
<h4>MultiPageEditor (package org.eclipse.ui.part)</h4>
<ul>
  <li>N.B. This class was previously deprecated</li>
  <li>The following former IEditorPart method was removed from this class
    because it was resource-specific:
    <ul>
      <li>public void gotoMarker(IMarker marker)</li>
    </ul>
  </li>
  <li>See above instructions for IEditorPart.gotoMarker.</li>
</ul>
<h4>MultiPageEditorPart (package org.eclipse.ui.part)</h4>
<ul>
  <li>The following former IEditorPart method was removed from this class
    because it was resource-specific:
    <ul>
      <li>public void gotoMarker(IMarker marker)</li>
    </ul>
  </li>
  <li>See above instructions for IEditorPart.gotoMarker.</li>
</ul>
<h4>IEditorLauncher (package org.eclipse.ui)</h4>
<ul>
  <li>The editor launcher interface is implemented by plug-ins that contribute
    external editors.</li>
  <li>The following method was removed from this interface because it was
    resource-specific:
    <ul>
      <li>public void open(IFile file)</li>
    </ul>
  </li>
  <li>It was replaced by
    <ul>
      <li>public void open(IPath file)</li>
    </ul>
  </li>
  <li>Clients that call IEditorLauncher.open(file) should instead call
    IEditorLauncher.open(file.getLocation()).</li>
  <li>Clients that implement this interface should replace their implementation
    of open(IFile) by one for open(IPath).</li>
</ul>
<h4>IEditorRegistry (package org.eclipse.ui)</h4>
<ul>
  <li>The following methods were removed from this interface because they were
    resource-specific:
    <ul>
      <li>public IEditorDescriptor getDefaultEditor(IFile file)</li>
      <li>public void setDefaultEditor(IFile file, String editorId)</li>
      <li>public IEditorDescriptor[] getEditors(IFile file)</li>
      <li>public ImageDescriptor getImageDescriptor(IFile file)</li>
    </ul>
  </li>
  <li>Clients that call getImageDescriptor(file) should call the
    &quot;String&quot; equivalent method. Thus rewrite getImageDescriptor(file)
    to be getImageDescriptor(file.getName())</li>
  <li>Clients that call setDefaultEditor(IFile file, String editorId) and
    getDefaultEditor(IFile file) should call the IDE equivalent methods. Thus
    <ul>
      <li>rewrite getDefaultEditor(file) to be IDE.getDefaultEditor(file)</li>
      <li>rewrite setDefaultEditor(file, id) to be IDE.setDefaultEditor(file,
        id)</li>
    </ul>
  </li>
  <li>Clients that call getEditors(file) should call the &quot;String&quot;
    equivalent method. Thus rewrite getEditors(file) to be
    getEditors(file.getName())</li>
  <li>The API contract for the following method was changed:
    <ul>
      <li>public IEditorDescriptor getDefaultEditor() is now deprecated. It will
        always return the System External Editor editor descriptor</li>
      <li>This change impacts clients that assumed the default editor returned
        would be a text editor.</li>
    </ul>
  </li>
  <li>New constants that represent the system external editor and system
    in-place editor identifiers (SYSTEM_EXTERNAL_EDITOR_ID and
    SYSTEM_INPLACE_EDITOR_ID). These two editors require an editor input that
    implements or adapts to org.eclipse.ui.IPathEditorInput. Note, the in-place
    editor descriptor will not exist on platforms that do not support in-place
    editing.</li>
</ul>
<h4>AbstractDocumentProvider (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>In order to free AbstractTextEditor from dependencies on
    org.eclipse.core.resources, AbstractDocumentProvider introduces the concept
    of document provider operations (DocumentProviderOperation) and document
    provider operation runner (IRunnableContext). When requested to perform
    reset, save, or synchronize, the AbstractDocumentProvider creates document
    provider operations and uses the operation runner to execute them. The
    runnable context can be provided by subclasses in the getOperationRunner
    method.</li>
  <li>Added protected abstract IRunnableContext getOperationRunner();
    non-abstract subclasses must implement this method in order to provide their
    own operation runner.</li>
  <li>The method resetDocument has been changed to final in order to allow the
    document provider to wrap the function with a document provider operation.
    The document provider operation calls the newly introduced doResetDocument
    method. AbstractDocumentProvider.doResetDocument contains the code that
    originally resided inside AbstractDocumentProvider.resetDocument. Subclasses
    must change their implementation of resetDocument to doResetDocument and any
    contained call of super.resetDocument to super.doResetDocument.</li>
  <li>The method saveDocument has been changed to final in order to allow the
    document provider to wrap the function with a document provider operation.
    The document provider operation calls the newly introduced doSaveDocument
    method. AbstractDocumentProvider.doSaveDocument contains the code that
    originally resided inside AbstractDocumentProvider.saveDocument. Subclasses
    must change their implementation of saveDocument to doSaveDocument and any
    contained call of super.saveDocument to super.doSaveDocument.</li>
  <li>The method synchronize has been changed to final in order to allow the
    document provider to wrap the function with a document provider operation.
    The document provider operation calls the newly introduced doSynchronize
    method. AbstractDocumentProvider.doSynchronize contains the code that
    originally resided inside AbstractDocumentProvider.synchronize. Subclasses
    must change their implementation of synchronize to doSynchronize and any
    contained call of super.synchronized to super.doSynchronize.</li>
</ul>
<h4>AbstractTextEditor (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>The method IEditorPart.gotoMarker(IMarker marker) was removed from the
    IEditorPart interface because it was resource-specific. The default
    implementation provided by AbstractTextEditor has been removed from
    AbstractTextEditor and has been moved to ExtendedTextEditor. Direct
    subclasses of AbstractTextEditor or StatusTextEditor that want to provide
    that functionality should follow the migration instructions given for
    IEditorPart in this document.</li>
  <li>AbstractTextEditor no longer differentiates between between implicit and
    explicit document providers as the concrete implementation was resource
    specific. This functionality has been moved to ExtendedTextEditor. Direct
    subclasses of AbstractTextEditor or StatusTextEditor must perform the
    following steps:
    <ul>
      <li>Override getDocumentProvider.</li>
      <li>Override the newly introduced hook method for disposing the document
        provider (disposeDocumentProvider)</li>
      <li>Override the newly introduced hook method
        setDocumentProvider(IEditorInput) that is called while updating the
        document provider for the new editor input. I.e. that is the method in
        which you can configure the appropriate implicit document provider for
        the given editor input.</li>
    </ul>
  </li>
  <li>All occurrences of WorkbenchModifyingOperation have been removed. The
    editor now calls the document provider methods directly (see described
    changes for AbstractDocumentProvider);
    <ul>
      <li>Removed createSaveOperation, changed performSaveOperation to
        performSave. Subclasses of AbstractTextEditor overriding
        createSaveOperation or performSaveOperation must now override
        performSave.</li>
      <li>Removed createdRevertOperation, changed peformRevertOperation to
        performRevert. Sunclasses overriding createRevertOperation or
        performRevertOperation must now override performRevert.</li>
      <li>The implementation of the method handleEditorInputChanged has been
        changed to not use WorkbenchModifyingOperation. Subclasses overriding
        handleEditorInputChange must adapt accordingly. Please use the changes
        applied to AbstractTextEditor.handleEditorInputChange as the blueprint.</li>
    </ul>
  </li>
  <li>AbstractTextEditor.createActions no longer registers any actions under
    ITextEditorActionConstants.ADD_TASK and ITextEditorActionConstant.BOOKMARK
    as those actions are IDE specific. The registration of these actions has
    been moved to ExtendedTextEditor. Direct subclasses of AbstractTextEditor or
    StatusTextEditor should override the createActions method and add the
    following lines (accordingly adapted to their circumstances):</li>
  <li>
    <pre> ResourceAction action= new AddMarkerAction(TextEditorMessages.getResourceBundle(), &quot;Editor.AddBookmark.&quot;, this, IMarker.BOOKMARK, true); //$NON-NLS-1$
  action.setHelpContextId(ITextEditorHelpContextIds.BOOKMARK_ACTION);
  action.setActionDefinitionId(ITextEditorActionDefinitionIds.ADD_BOOKMARK);
  setAction(IDEActionFactory.BOOKMARK.getId(), action);     </pre>
    <pre>  action= new AddTaskAction(TextEditorMessages.getResourceBundle(), &quot;Editor.AddTask.&quot;, this); //$NON-NLS-1$
  action.setHelpContextId(ITextEditorHelpContextIds.ADD_TASK_ACTION);
  action.setActionDefinitionId(ITextEditorActionDefinitionIds.ADD_TASK);
  setAction(IDEActionFactory.ADD_TASK.getId(), action);</pre>
  </li>
</ul>
<h4>StatusTextEditor (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>See migration notes for AbstractTextEditor.</li>
  <li>StatusTextEditor provides the predicate method isErrorStatus(IStatus).
    Subclasses may override in order to decide whether a given status must
    considered an error or not.</li>
</ul>
<h4>ExtendedTextEditor (package org.eclipse.ui.editors.text)</h4>
<ul>
  <li>The IEditorPart method gotoMarker(IMarker marker) has been deprecated to
    allow a future change of its visibility. Clients of this method must follow
    the migration instructions in the deprecation message.
  <li>ExtendedTextEditor returns an adapter for IGotoMarker.
  <li>ExtendedTextEditor implements the concept of implicit/explicit document
    providers previously provided by AbstractTextEditor. See migration notes for
    AbstractTextEditor.
</ul>
<h4>StorageDocumentProvider (package eclipse.ui.editors.text)</h4>
<ul>
  <li>See migration notes for AbstractDocumentProvider.</li>
  <li>Implements the getOperationRunner method defined by
    AbstractDocumentProvider. Always returns null. When subclassing you should
    not be affected by this change.</li>
</ul>
<h4>FileDocumentProvider (packge org.eclipse.ui.editors.text)</h4>
<ul>
  <li>See migration notes for AbstractDocumentProvider.</li>
  <li>The method resetDocument has been changed to doResetDocument.</li>
  <li>The method synchronize has been changed to doSynchronize.</li>
  <li>Implements the getOperationRunner method returning
    WorkspaceOperationRunner which executes given DocumentProviderOperations
    inside a WorkspaceModifyingOperation.</li>
</ul>
<h3>Generic Console</h3>
<p>With the work for the generic console support, the view id for the console
has changed from org.eclipse.debug.ui.ConsoleView. This results in problems at
startup such as &quot;Could not restore workbench layout&quot; with details that
&quot;Could not create view: org.eclipse.debug.ui.ConsoleView&quot; for the
particular perspective that contained reference to the old view id. The
equivalent view id is now: &quot;org.eclipse.ui.console.ConsoleView&quot;.<br>
The generic console is available via the Window&gt;Show View&gt;Basic&gt;Console
and is used by the Eclipse debug and Ant integration.</p>
<h3>[JDT only] IJavaBreakpointListener (package org.eclipse.jdt.debug.core)</h3>
<p>In 3.0, the return types for the methods
IJavaBreakpointListener.breakpointHit(IJavaBreakpoint, IJavaThread) and
installingBreakpoing(IJavaTarget, IJavaBreakpoint, IJavaType) changed from
boolean to int to allow listeners to vote &quot;don't care&quot;. In releases
prior to 3.0, listeners could only vote &quot;suspend&quot; or &quot;don't
suspend&quot; when a breakpoint was hit, and &quot;install&quot; or &quot;don't
install&quot; when a breakpoint was about to be installed. In 3.0, listeners can
also vote &quot;don't care&quot; for either of these notifications. This allows
clients to only make a decisive vote in situations that they care about. For
&quot;breakpoint hit&quot; notifications, the breakpoint will suspend if any
listeners vote &quot;suspend&quot;, or all listeners vote &quot;don't
care&quot;; and it will not suspend if at least one listener votes &quot;don't
suspend&quot; and no listeners vote &quot;suspend&quot;. Similarly, for
&quot;breakpoint installing&quot; notifications, the breakpoint will be
installed if any listeners vote to install, or all listeners vote &quot;don't
care&quot;; and it will not be installed if at least one listener votes
&quot;don't install&quot; and no listeners vote &quot;install&quot;. In general,
implementors should return DONT_CARE unless they have a strong opinion one way
or the other. It is important to keep in mind, for example, that voting
&quot;suspend&quot; will override any other listener's vote of &quot;don't
suspend&quot;.</p>
<p>The IJavaBreakpointListener interface is implemented by clients that create
or react to breakpoints in Java code. There are likely few clients beyond JDT
itself, save the one that reported the problem (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=37760">bug
37760</a>) that this change remedies. This is a breaking change for existing
code that implements the IJavaBreakpointListener interface. This code needs to
be modified to return an appropriate int value before it will compile or run in
3.0.</p>
<h3>Clipboard access in UI thread (package org.eclipse.swt.dnd)</h3>
<p>Prior to 3.0, the methods on the SWT Clipboard class were tacitly permitted
to run in threads other than the UI thread. This oversight resulted in failures
on GTK where the operating system requires that clipboard interactions be
performed in the UI thread. The oversight was not revealed earlier because many
applications are single-threaded and receive most of their testing on Windows.
In order for the Clipboard API to be sustainable and cross-platform, in 3.0 the
specification and implementation of all Clipboard API methods have been changed
to throw an SWT Exception (ERROR_THREAD_INVALID_ACCESS) if invoked from a non-UI
thread. Clipboard services are commonly provided automatically by Eclipse
components such as the text editor, which insulate many clients from this
breaking change. Existing code that does make direct use of Clipboard should
ensure that the API methods are called on the correct thread, using
Display.asyncExec or syncExec as required to shift accesses into the UI thread.</p>
<h3>SWT.KeyDown events</h3>
<p>In 3.0 key down events are reported before the work is done in the OS. This
is much earlier than it was prior to 3.0. This change was made to support key
bindings in Eclipse which necessitates intercepting key events before any widget
had a chance to process the character. Consequences of this change are visible
to code that handles low-level SWT.KeyDown events directly. For example, it
means that when a listener on a Text widget receives a key down event, the
widget's content (getText()) will not yet include the key just typed (it would
have prior to 3.0). The recommended way to get the full text from the widget
including the current key is to handle the higher-level SWT.Modify or SWT.Verify
events rather than the low-level SWT.KeyDown event; code that does it this way
is unaffected by this change.</p>
<h3>Tab traversal of SWT Canvas (package org.eclipse.swt.widgets)</h3>
<p>Prior to 3.0, when the focus was in an SWT Canvas or one of its subclasses
(including custom widgets), typing Ctrl+Tab, Shift+Tab, Ctrl+PgUp, or Ctrl+PgDn
would automatically trigger traversal to the next/previous widget without
reporting a key event. This behavior was unspecified, and runs counter to the
rule that Canvases see every key typed in them. The proper way to handle
traversal is by registering a traverse listener. In order to properly support
Eclipse key bindings in 3.0, the default behavior was changed so that Canvas now
sees Ctrl+Tab, Shift+Tab, Ctrl+PgUp, and Ctrl+PgDn key events instead of
traversing. If you use a raw Canvas or define a subclass of Canvas, ensure that
that you register a traverse listener.</p>
<h3>Selection event order in Table and Tree widgets</h3>
<p>Mouse selections of items in SWT Table and Tree widgets generate the event
sequence MouseDown-Selection-MouseUp uniformly in all operating environments.
Similarly, keyboard selections generate the event sequence
KeyDown-Selection-KeyUp uniformly in all operating environments. Prior to 3.0,
the event order was not uniform, with Motif and Photon at variance with the rest
by always reporting the Selection event first; i.e., Selection-MouseDown-MouseUp
or Selection-KeyDown-KeyUp. For 3.0, the event order on Motif and Photon has
been changed to match the others. Existing code that was functioning correctly
on {Windows, GTK} and on {Motif, Photon} is unlikely to be affected. But it is
wise to check your code to ensure that it does not rely on an invalid event
order.</p>
<h3>IStatus (org.eclipse.core.runtime)</h3>
<p>
<code>IStatus</code> has a new severity constant, <code>IStatus.CANCEL</code>,
that can be used to indicate cancelation. Callers of <code>IStatus.getSeverity</code>
that relied on the assumption that the set of possible severities was closed may be
affected by this addition. Callers of <code>getSeverity</code> may need to update 
their code to include the new severity.</p>
<h3>IResourceChangeEvent (org.eclipse.core.resources)</h3>
<p>In Eclipse 3.0, workspace auto-build now occurs in a background thread. This
required an API contract change to <tt>IResourceChangeEvent</tt>. The contract
of <tt>IResourceChangeEvent</tt> previously guaranteed the following ordering of
events for all workspace changes:
<ol>
  <li><tt>PRE_DELETE</tt> or <tt>PRE_CLOSE</tt> event notification if applicable</li>
  <li>Perform the operation</li>
  <li><tt>PRE_AUTO_BUILD</tt> event notification</li>
  <li>If auto-build is on, perform incremental workspace build</li>
  <li><tt>POST_AUTO_BUILD</tt> event notification</li>
  <li><tt>POST_CHANGE</tt> event notification</li>
</ol>
<p>With auto-build now running in the background, there is no longer any
guarantee about the temporal relationship between the <tt>AUTO_BUILD</tt> events
and the <tt>POST_CHANGE</tt> event. In Eclipse 3.0, steps 3-5 in the above
structure are removed from the operation. The resulting picture looks like this:
<ol>
  <li><tt>PRE_DELETE</tt> or <tt>PRE_CLOSE</tt> event notification if applicable</li>
  <li>Perform the operation</li>
  <li><tt>POST_CHANGE</tt> event notification</li>
</ol>
<p>Periodically, the platform will perform a background workspace build
operation. Note that this happens regardless of the whether auto-build is on or
off. The exact timing of when this build occurs will not be specified. The
structure of the build operation will look like this:
<ol>
  <li><tt>PRE_AUTO_BUILD</tt> event notification</li>
  <li>If auto-build is on, perform incremental workspace build</li>
  <li><tt>POST_AUTO_BUILD</tt> event notification</li>
  <li><tt>POST_CHANGE</tt> event notification</li>
</ol>
The reference point for the deltas received by auto-build listeners will be
different from post-change listeners. Build listeners will receive notification
of all changes since the end of the last build operation. Post-change listeners
will receive a delta describing all changes since the last post-change
notification. This new structure retains three characteristics of resource
change listeners that have been true since Eclipse 1.0:
<ul>
  <li><tt>POST_CHANGE</tt> listeners receive notification of absolutely all
    resource changes that occur during the time they are registered. This
    includes changes made by builders, and changes made by other listeners.</li>
  <li><tt>PRE_AUTO_BUILD</tt> listeners receive notification of all resource
    changes <b>except</b> changes made by builders and resource change
    listeners.
  <li><tt>POST_AUTO_BUILD</tt> listeners receive notification of all resource
    changes <b>except</b> changes made by other <tt>POST_AUTO_BUILD</tt>
    listeners.
</ul>
However, there are some important differences with this approach. Prior to
Eclipse 3.0, auto-build listeners were always called before <tt>POST_CHANGE</tt>
listeners. For this reason, the delta received by auto-build listeners was
always a subset of the delta received by the <tt>POST_CHANGE</tt> listeners.
This relationship is now essentially reversed. Auto-build listeners will receive
a delta that is a super-set of all deltas supplied to <tt>POST_CHANGE</tt>
listeners since the end of the last background build. As before, auto-build
listeners will be allowed to modify the workspace, and post-change listeners
will not.
<p>It will no longer be true that upon completion of a workspace changing
operation, that <tt>AUTO_BUILD</tt> event listeners will have been notified.
Client code that registers resource change listeners with <code>IWorkspace.addResourceChangeListener(IResourceChangeListener)</code>
is&nbsp; unlikely to be affected by this change because <tt>AUTO_BUILD</tt>
events were never reported to these listeners. However, clients that use <code>IWorkspace.addResourceChangeListener(IResourceChangeListener,int)</code>
and specify an event mask that includes <tt>AUTO_BUILD</tt> events are likely to
be broken by this change if they make assumptions about when auto-build
listeners run or what thread they run in. For example, if an auto-build listener
is updating a domain model to reflect changes to the workspace, then this update
might not have happened when the workspace changing operation returns. It is
worth noting that only UI-level code can be affected in this way. Core-level
code that is called via API may be called within the scope of an <tt>IWorkspaceRunnable</tt>,
so it can never be sure about when resource change listeners will be called. The
suggested fix for this breakage is to use <tt>POST_CHANGE</tt> instead of build
listeners if it is necessary to have notification occur before the operation
completes.</p>
<h3>IWorkspaceRunnable and IWorkspace.run</h3>
<p>It will no longer be guaranteed that all resource changes that occur during
the dynamic scope of an <code>IWorkspaceRunnable</code> will be batched in a
single notification. This mechanism can still be used for batching changes to
avoid unnecessary builds and notifications, but the platform may now decide to
perform notifications during the operation. This API contract change is not
likely to be a breaking change for existing clients. It is equivalent to the
platform deciding to call <code>IWorkspace.checkpoint</code> periodically during
a long running operations. The reason for this change is that it is now possible
for multiple threads to be modifying the workspace concurrently. When one thread
finishes modifying the workspace, a notification is required to prevent
responsiveness problems, even if the other operation has not yet completed. This
change also allows users to begin working on a set of resources before the
operation completes. For example, a user can now begin browsing files in a
project that is still in the process of being checked out. The new method <tt>IWorkspace.run(IWorkspaceRunnable,
ISchedulingRule, int, IProgressMonitor)</tt> has an optional flag, <tt>AVOID_UPDATE</tt>,
that operations can use as a hint to the platform to specify whether periodic
updates are desired.</p>
<h3>Eclipse 3.0 is more concurrent</h3>
<p>Prior to Eclipse 3.0, Eclipse operated mostly in a single thread. Most API
methods and extension points operated either in the UI thread, or in a thread
spawned from a progress dialog that blocked the UI thread. Most plug-in writers
did not have to worry much about thread safety, apart from ensuring that all UI
activity occurred in the UI thread. In Eclipse 3.0, there is generally much more
concurrency. Many operations now occur in a background thread, where they may
run concurrently with other threads, including the UI thread. All plug-ins whose
code runs in a background thread must now be aware of the thread safety of their
code.</p>
<p>In addition to plug-ins that are explicitly running operations in the
background using the <tt>org.eclipse.core.runtime.jobs</tt> API, there are
several platform API facilities and extension points that make use of background
threads. Plug-ins that hook into these facilities need to ensure that their code
is thread safe. The following table summarizes the API and extension points that
run some or all of their code in a background thread in Eclipse 3.0:</p>
<p>&nbsp;
<table border="1" width="80%">
  <tr>
    <td width="50%">
      <p align="center"><b>Extension point or API class</b></td>
    <td width="50%">
      <p align="center"><b>Notes</b></td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.core.runtime.IRegistryChangeListener</td>
    <td width="50%">New in Eclipse 3.0, runs in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.core.resources.IResourceChangeListener</td>
    <td width="50%"><tt>AUTO_BUILD</tt> events now in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.core.resources.builders</td>
    <td width="50%">Autobuild now in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.core.resources.ISaveParticipant</td>
    <td width="50%"><tt>SNAPSHOT</tt> now in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.workbench.texteditor.quickdiffReferenceProvider</td>
    <td width="50%">New in Eclipse 3.0, runs in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.decorators</td>
    <td width="50%">Already in background in Eclipse 2.1</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.ui.startup</td>
    <td width="50%">Already in background in Eclipse 2.1</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.team.core.org.eclipse.team.core.repository</td>
    <td width="50%">Many operations now in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.team.ui.synchronizeParticipants</td>
    <td width="50%">New in Eclipse 3.0, runs in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.debug.core.launchConfigurationTypes</td>
    <td width="50%">Now runs in background</td>
  </tr>
  <tr>
    <td width="50%">org.eclipse.jdt.core.IElementChangedListener</td>
    <td width="50%"><tt>PRE_AUTO_BUILD</tt> now runs in background, <tt>POST_RECONCILE</tt>
      already ran in the background</td>
  </tr>
</table>
<p>There are various strategies available for making code thread safe. A naive
solution is to ensure all work occurs in the UI thread, thus ensuring serialized
execution. This is a common approach for UI plug-ins that are not doing
CPU-intensive processing. When doing this, be aware of the deadlock risk
inherent in <tt>Display.syncExec</tt>. <tt>Display.asyncExec</tt> is generally
safer as it does not introduce deadlock risk, at the expense of losing precise
control over when the code is executed.</p>
<p>Other techniques for making thread safe code included:
<ul>
  <li>Wrapping unsafe code in semaphores or java monitors. The new concurrency
    infrastructure includes one such semaphore object: <tt>org.eclipse.core.runtime.jobs.ILock</tt>.
    The advantage of <tt>ILock</tt> over generic locks is that they transfer
    automatically to the UI thread when doing a <tt>syncExec</tt>, and there is
    deadlock detection support built into their implementation that logs and
    then resolves deadlocks.</li>
  <li>Message queues. Code can be serialized by forwarding all processing to a
    message queue that is processed serially in a single thread. One such
    example is the SWT deferred event queue (<tt>Display.asyncExec</tt>), which
    is processed entirely in the UI thread.</li>
  <li>Immutable objects. Make data structures immutable, and make new copies on
    modification. This is the approach used to make data structures such as <tt>java.lang.String</tt>
    and <tt>org.eclipse.core.runtime.IPath</tt> thread safe. The advantage of
    immutable objects is extremely fast read access, at the cost of extra work
    on modification.</li>
</ul>
<h3>Restructuring of Platform Core Runtime</h3>
<p>The Eclipse 3.0 Platform Runtime is based on OSGi, necessitating changes to
the structure of the two Platform Runtime plug-ins, org.eclipse.core.runtime and
org.eclipse.core.boot.</p>
<p>A new org.eclipse.core.runtime.compatibility plug-in provides an
implementation bridge between the old and new APIs, and is the new home for some
of the obsolete APIs formerly found in org.eclipse.core.runtime and
org.eclipse.core.boot. Obsolete API will be deprecated in a future release in
favor of the OSGi-based API, once these new APIs have stabilized and matured.
The new OSGi-based Eclipse Runtime API is available in the
org.eclipse.core.runtime plug-in for early adopters wishing to take advantage of
its new capabilities. Platform Runtime extension points were not affected by the
restructuring.</p>
<p>N.B. The Eclipse 3.0 runtime automatically detects pre-3.0 plug-ins (by the
absence of the aforementioned &lt;?eclipse...?&gt; line in the plug-in manifest)
and automatically compensates for these changes to the Platform Runtime. This
should be viewed as a stopgap measure to allow existing plug-in that explicitly
or implicitly depends on org.eclipse.core.runtime or org.eclipse.core.boot to
work in 3.0. However, when porting the existing plug-in to 3.0, the plug-in's
manifest needs to be updated to reflect the new structure of the Eclipse
Platform Runtime plug-ins. The PDE plug-in manifest migration tool will add a
dependency to org.eclipse.core.runtime.compatibility if required.</p>
<p>Note also that if you mark you plug-in as 3.0 (using &lt;?eclipse...?&gt;)
and your plug-in defines a Plugin class, you must either explicitly &lt;import
plugin=&quot;org.eclipse.core.runtime.compatibility&quot;/&gt; in the plug-in
manifest or ensure that the Plugin class defines the default constructor.</p>
<h3>URL Stream Handler extensions</h3>
<p><strong>Who is affected:</strong> Plug-ins that contribute extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt>
extension point.</p>
<p><strong>Description:</strong> The contract for the <tt>org.eclipse.core.runtime.urlHandlers</tt>
extension point was changed to use the URL Stream Handler service provided by
OSGi. The OSGi support is superior to the one in Eclipse 2.1, and correctly
handles dynamic handlers. Because of various design issues with the base Java
URL handler mechanism, URLStreamHandlers registered with the OSGi handler
service must implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>.</p>
<p><strong>Action required:</strong> Formerly, the handler class had to
implement <tt>java.net.URLStreamHandler</tt> and extend the urlHandlers
extension point. The extension point is no longer supported and the handler must
be updated to implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>
interface. The OSGi framework provides an abstract base class (<tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>)
that can be trivially subclassed to fill this role.</p>
<p>Instead of registering the handler using an extension point, plug-ins must
now do so by registering their handler as a service. For example,</p>
<pre>    Hashtable properties = new Hashtable(1);
    properties.put(URLConstants.URL_HANDLER_PROTOCOL, new String[] {MyHandler.PROTOCOL});
    String serviceClass = URLStreamHandlerService.class.getName();
    context.registerService(serviceClass, new MyHandler(), properties);
</pre>
<h3>Classload order</h3>
<p><b>Who is affected:</b> Plug-ins which supply packages provided which are
also supplied by other plug-ins. A very limited number of plug-ins are affected
by this change and some of those affected will actually benefit (see below).</p>
<p><b>Description:</b> In Eclipse 2.x, classloaders search for classes using the
so-called <i>PSP</i> ordering. That is, a given classloader would first consult
its <b>p</b>arent classloader (in practice this is the Java boot classloader),
then its own classpath contents (i.e., <b>s</b>elf) and finally all of its <b>p</b>rerequisites
in declared order. OSGi offers an optimization over this model, the so-called <i>PP|S</i>
(read P, P or S) ordering. In this approach a classloader will consult its
parent (again, effectively the Java boot classloader), then either a single
prerequisite known to contribute classes in the package being queried then its
own classpath entries for the desired class.</p>
<p>The classloader determines whether to consult self or its prerequisites based
on its imported and required packages. This information is inferred from the
plug-in content in the case of legacy plug-ins and directly specified in the
case of new plug-ins. In either case, it is known <i>a priori</i> which
classloaders will supply the classes for which packages. This offers performance
improvements as well as a solution to the vexing problem of multiple
prerequisites contributing the same classes.</p>
<p>Take for example the case of Xerces and Xalan. Both contain various classes
from org.xml packages. Under the PSP model, the Xerces plug-in would see its
copy of these classes while the Xalan plug-in would see their copy. Since these
plug-ins need to communicate, ClassCastExceptions occur. Under the PP|S model,
only one of the two plug-ins contributes the duplicate classes and both plug-ins
see the same copies.</p>
<p><b>Action required:</b> The action required depends on the particulars of the
usecase. Affected developers need to review their classpath and resolve any
conflicts which may be happening.</p>
<h3>Class loader protection domain not set</h3>
<p><b>Who is affected:</b> Plug-ins which expect the protection domain of their
class loader to be set at all times.</p>
<p><b>Description:</b> In Eclipse 2.1 plug-in class loaders were
SecureClassloaders. As such, they always had a protection domain set. In Eclipse
3.0 classloaders do not extend SecureClassloader and only set the protection
domain if Java security is turned on (not the normal case).</p>
<p><b>Action required:</b> The action required will depend on the scenario in
which the plug-in is using the protection domain.</p>
<h3>PluginModel object casting</h3>
<p><b>Who is affected:</b> Plug-ins which cast objects of type IPlugin* to
Plugin*Model. Even though the relationship between these interfaces and the
model classes is not a specified part of the Eclipse 2.1 API we are explicitly
calling out this change as we have found that PDE and a few others are currently
take advantaging of the correlation in the 2.1 implementation.</p>
<p><b>Description:</b> The Eclipse API provides a series of interfaces (e.g., <tt>IPluginDescriptor</tt>)
and so-called &quot;model&quot; classes (e.g., <tt>PluginDescriptorModel</tt>)
related to plug-ins and the plug-in registry. In the Eclipse 2.1 implementation
it happens that the model classes implement the relevant interfaces. In the new
runtime the plug-in registry has been significantly reworked to allow for a
separation between the classloading and prerequisite aspects of plug-ins and the
extension and extension-point aspects. As such the Eclipse 3.0 runtims is unable
to maintain the implementation relationship present in 2.1.</p>
<p><b>Action required:</b> Developers currently relying on this non-API
relationship will need to rework their code according to their usecase. More
information on this is given in the recommended changes section of this document
and in the Javadoc for the related classes and methods.</p>
<h3>ILibrary implementation incomplete</h3>
<p><b>Who is affected:</b> User of <tt>org.eclipse.core.runtime.ILibrary</tt>.</p>
<p><b>Description:</b> The new runtime maintains the classpath entries in a
different and incompatible form from Eclipse. As a result, the compatibility
layer is unable to correctly model the underlying OSGi structures as ILibrary
objects. The runtime's compatibility support creates ILibrary objects but must
assume default values for everything except the library's path.</p>
<p><b>Action required:</b> Users of ILibrary should consider accessing the
desired header values (e.g., <tt>Bundle-Classpath</tt>) from the appropriate
Bundle (see <tt>Bundle.getHeaders()</tt>) and using the <tt>ManifestElement</tt>
helper class to interpret the entries. See the class Javadoc for more details.</p>
<h3>Invalid assumptions regarding the form of URLs</h3>
<p><b>Who is affected:</b> Plug-ins which make assumptions regarding their
installation structure, location and the local file system layout.</p>
<p><b>Description:</b> Methods such as <tt>IPluginDescriptor.getInstallURL()</tt>
return URLs of a particular form. Despite this form not being specified, various
plug-ins make assumptions based on the current implementation. For example, they
may expect to get a <tt>file:</tt> URL and use URL.getFile() and use <tt>java.io.File</tt>
manipulation on the result. To date, this has been a workable but rather unsafe
approach. For example, if a plug-in is installed on a web server, it is possible
that an <tt>http:</tt> URL would be returned. The new Eclipse 3.0 runtime is
even more flexible and opens more possibilities for execution configurations
(e.g., maintaining whole plug-ins in JARs rather than exploded in directories).
That is , while new runtime does not actually break 2.1 API, it exposes more
cases where assumptions made in current plug-ins are invalid.</p>
<p><b>Action required:</b> Plug-in writers should ensure that the information to
which they need access is available via <tt>getResource()</tt> (and is on the
classpath) or use the relevant API for accessing the contents of a plug-in
(e.g., <tt>Bundle.getEntry(String)</tt>).</p>
<h3>BootLoader API methods moved/deleted</h3>
<p><b>Who is affected:</b> Plug-ins which use certain API methods from the class
<tt>org.eclipse.core.boot.BootLoader</tt>.</p>
<p><b>Description:</b> Methods such as startup(), shutdown() and run() were
moved from the BootLoader class (now supplied in the compatibility layer) to
EclipseStarter which is part of the OSGi framework (i.e., org.eclipse.osgi).
This API is the interface between the main() in startup.jar and the OSGi
framework/Eclipse runtime. Given the restructuring of the runtime, these methods
could not be left on BootLoader.</p>
<p>The method BootLoader.getRunnable() has been removed as the runtime can no
longer support the acquisition of individual applications. Rather users should
indicate the application of interest when they start the platform.</p>
<p><b>Action required:</b> In general this API is used by very few people. In
the rare case that it is, users can adapt by using the new methods on
EclipseStarter.</p>
<h3>Re-exporting runtime API</h3>
<p><b>Who is affected:</b> Plug-ins which expose API that includes elements from
changed runtime API.</p>
<p><b>Description:</b> Various plug-ins expose API that includes elements from
the runtime API. With the changes to the Eclipse 3.0 runtime outlined here,
client plug-ins must re-evaluate their use of runtime API in their API.</p>
<p><b>Action required:</b> This scenario is quite quite rare are very little of
the Eclipse runtime API is changing. Depending on the scenario, clients may have
to change their API or continue to rely on the the compatibility layer.</p>
<h3>Plug-in parsing methods on Platform</h3>
<p><b>Who is affected:</b> Users of <tt>org.eclipse.core.runtime.Platform.parsePlugins(...,
Factory).</tt></p>
<p><b>Description:</b> The method <tt>org.eclipse.core.runtime.Platform.parsePlugins(...,
Factory)</tt> has been moved. The API associated with the Factory argument has
been moved from the org.eclipse.core.runtime plug-in up to the
org.eclipse.core.runtime.compatibility plug-in (which depends on the runtime
plug-in). As a result, the parsing method has been moved as well.</p>
<p><b>Action required:</b> Users of this method should use the same method on
the class <tt>org.eclipse.core.runtime.model.PluginRegistryModel</tt>.</p>
<h3>Plug-in libraries supplied by fragments</h3>
<p><strong>Who is affected:</strong> Plug-ins which specify code on their
classpath but do not supply that code (i.e., it is supplied by a fragment).</p>
<p><strong>Description:</strong> The new runtime must convert plug.xml files to
manifest.mf files. This is done through a straight mechanical transformation and
an analysis of the jars listed and supplied by the plug-in. In the case where a
plug-in specifies a jar on its classpath but does not supply the jar, there is
no code to analyze and the plug-in convertor cannot generate a correct
manifest.mf. The SWT plug-in is in this situation.</p>
<p><strong>Action required:</strong> Providers of such plug-ins must either
change to supply the appropriate jar in the plug-in itself or hand
craft/maintain a META-INF/MANIFEST.MF file for their plug-in. Typically this can
be done using PDE to get the initial manifest and then adding in the appropriate
Provide-Package header.</p>
<h3>Changes to build scripts</h3>
<p><b>Who is affected:</b> Developers maintaining scripts (e.g., Ant build.xml
files) which define classpaths containing runtime related jars and class
directories.</p>
<p><b>Description:</b> The new runtime contains a number of new plug-ins and
jars. Their introduction was mandated by the refactoring of the runtime into
configurable pieces. For most runtime situations these changes are transparent.
However, if you have custom build.xml (or similar) scripts which currently
compile code against <tt>org.eclipse.core.runtime</tt>, you will need to update
them before they will function correctly. A typical script contains a classpath
entry in a &lt;javac&gt; task that references the <tt>org.eclipse.core.runtime</tt>
plug-in as follows:</p>
<pre>    ../org.eclipse.core.runtime/bin;../org.eclipse.core.runtime/runtime.jar</pre>
<p>The runtime plug-in continues to contain much of the original runtime code.
However, various parts of the runtime which are there only for compatibility
purposes are contained in a compatibility plug-in (<tt>org.eclispe.core.runtime.compatibility</tt>).
Most of the new runtime code is contained in a collection of plug-ins (<tt>org.eclipse.osgi.*</tt>).</p>
<p><b>Action required:</b> Developers should add the entries below as needed to
eliminate compilation errors. While the complete set of jars supplied is listed
below, typical uses require only a subset on the classpath at compile time. As
usual, the inclusion of the /bin directories is discretionary. The entries are
given here in logical groupings by supplying plug-in:</p>
<ul>
  <li>../org.eclipse.core.runtime.compatibility/bin;../org.eclipse.core.runtime.compatibility/compatibility.jar;</li>
  <li>../org.eclipse.osgi/bin;../org.eclipse.osgi/osgi.jar;</li>
  <li>../org.eclipse.update.configurator/bin;../org.eclipse.update.configurator/configurator.jar;</li>
  <li>../org.eclipse.osgi.util/util.jar;</li>
</ul>
<p>In addition the following jars may be required in special cases:</p>
<ul>
  <li>../org.eclipse.osgi/core.jar; ../org.eclipse.osgi/resolver.jar; ../org.eclipse.osgi/defaultAdaptor.jar;
    ../org.eclipse.osgi/eclipseAdaptor.jar; ../org.eclipse.osgi/console.jar</li>
</ul>
<p>While updating such scripts, you should also take the opportunity to clean up
(i.e., remove) references to <tt>org.eclipse.core.boot</tt>. This plug-in is
obsolete and longer contains any code. The entries can be left on the classpath
but they serve no purpose and should be removed. Look to remove:<br>
</p>
<pre>    ../org.eclipse.core.boot/bin;../org.eclipse.core.boot/boot.jar</pre>

<h3>Changes to pde build ant task</h3>
<p><b>Who is affected:</b> Developers maintaining scripts (e.g., Ant build.xml
files) using the eclipse.buildScript task.</p>
<p><b>Description:</b> PDE Build introduced a new property to the eclipse.buildScript task to control the generation of plug-ins build script. 
This was mandated by the introduction of the new runtime.
<p><b>Action required:</b> If you want to use eclipse 3.0 to build a 2.1 based product, 
then introduce in eclipse.buildScript call the property "buildingOSGi" and set it to false.
For example: <pre>&lt;eclipse.buildScript ... buildingOSGi="false"/&gt;</pre>

<h3>org.apache.xerces plug-in</h3>
<p>The org.eclipse.xerces plug-in is no longer included. Basic XML parsing
support is built in to J2SE 1.4, and the presence of the Xerces plug-in creates
class loader conflicts. The javax.xml.parsers, org.w3c.dom.*, and org.xml.sax.*
API packages formerly provided by the org.eclipse.xerces plug-in are now
available from J2SE.</p>
<p>If your plug-in requires org.eclipse.xerces, you must change your plug-in
manifest to remove this dependency.</p>
<h3>Removal of install.ini</h3>
<p>The install.ini file is no longer included. In its place is the new
config.ini file in the configuration sub-directory. Products that used the
install.ini file to specify a primary feature (e.g., to provide branding
information) need to make changes to the config.ini file instead. In addition to
the new filename, the names of the keys have changed.</p>
<p>The value of the feature.default.id key in 2.1 should be set as the value of
the new eclipse.product key. The value of the eclipse.application should be set
to &quot;org.eclipse.ui.ide.workbench&quot;.</p>
<p>Finally, in 2.1 the image for the splash image was always splash.bmp in the
branding plug-in's directory. In 3.0 the location of the splash image is
provided explicitly by the osgi.splashPath key in the config.ini file.</p>
<h2><a name="Recommended Changes for 3.0">Recommended Changes for 3.0</a></h2>
<p>This section describes other changes that we recommend be made when porting
an existing plug-in to 3.0.</p>
<h3>Changes to API classes and interfaces (by package)</h3>
<h4>IWorkspaceRunnable and IWorkspace.run (org.eclipse.core.runtime)</h4>
<p>Clients of the <tt>IWorkspace.run(IWorkspaceRunnable,IProgressMonitor)</tt>
method should revisit their uses of this method and consider using the richer
method <tt>IWorkspace.run(IWorkspaceRunnable,ISchedulingRule,int,IProgressMonitor)</tt>.
The old <tt>IWorkspace.run</tt> method acquires a lock on the entire workspace
for the duration of the <tt>IWorkspaceRunnable</tt>. This means that an
operation done with this method will never be able to run concurrently with
other operations that are changing the workspace. In Eclipse 3.0, many
long-running operations have been moved into background threads, so the
likelihood of conflicts between operations is greatly increased. If a modal
foreground operation is blocked by a long running background operation, the UI
becomes blocked until the background operation completes, or until one of the
operations is canceled.</p>
<p>The suggested solution is to switch all references to old <tt>IWorkspace.run</tt>
to use the new method with a scheduling rule parameter. The scheduling rule
should be the most fine-grained rule that encompasses the rules for all changes by that
operation. If the operation tries to modify resources outside of the scope
of the scheduling rule, a runtime exception will occur. The precise scheduling rule
required by a given workspace operation is not specified, and may change depending
on the installed repository provider on a given project. The factory 
<code>IResourceRuleFactory</code> should be used to obtain the scheduling
rule for a resource-changing operation. If desired, a <tt>MultiRule</tt> can be used 
to specify multiple resource rules, and the <tt>MultiRule.combine</tt> convenience 
method can be used to combine rules from various resource-changing operations.
<p>
If no locking is required, a scheduling rule of <tt>null</tt> can be used. This will
allow the runnable to modify all resources in the workspace, but will not prevent other
threads from also modifying the workspace concurrently. For simple changes to 
the workspace this is often the easiest and most concurrency-friendly solution.
</p>
<h4>IWorkbenchPage (package org.eclipse.ui)</h4>
<ul>
  <li>The constant EDITOR_ID_ATTR is now deprecated. This is an IMarker
    attribute name that specifies the preferred editor id to open the IMarker
    resource with. This constant in now on org.eclipse.ui.ide.IDE class.</li>
</ul>
<h4>IEditorDescriptor (package org.eclipse.ui)</h4>
<ul>
  <li>There are new API methods to determine whether the editor will open
    internally to the workbench page (isInternal), in-place to the workbench
    window (isOpenInPlace), or externally to the workbench (isExternal). While
    this is not a breaking change, it is a good opportunity for clients that are
    illegally down-casting IEditorDescriptor to
    org.eclipse.ui.internal.model.EditorDescriptor to call isInternal to bring
    there code back into line.</li>
</ul>
<h4>ISharedImages (package org.eclipse.ui)</h4>
<ul>
  <li>The following fields were removed (deprecated) from this interface because
    they were IDE-specific:
    <ul>
      <li>String IMG_OBJ_PROJECT</li>
      <li>String IMG_OBJ_PROJECT_CLOSED</li>
      <li>String IMG_OPEN_MARKER</li>
      <li>String IMG_OBJS_TASK_TSK</li>
      <li>String IMG_OBJS_BKMRK_TSK</li>
    </ul>
  </li>
  <li>Existing clients should instead use the fields of the same names declared
    on IDE.SharedImages in the org.eclipse.ui.ide package of the
    org.eclipse.ui.ide plug-in.</li>
</ul>
<h4>IWorkbenchActionConstants (package org.eclipse.ui)</h4>
<ul>
  <li>The following fields were removed (deprecated) from this interface; they
    are subsumed by the new ActionFactory class:
    <ul>
      <li>String ABOUT</li>
      <li>String BACK</li>
      <li>String CLOSE</li>
      <li>String CLOSE_ALL</li>
      <li>String COPY</li>
      <li>String CUT</li>
      <li>String DELETE</li>
      <li>String EXPORT</li>
      <li>String FIND</li>
      <li>String FORWARD</li>
      <li>String IMPORT</li>
      <li>String MOVE</li>
      <li>String NEW</li>
      <li>String NEXT</li>
      <li>String PASTE</li>
      <li>String PREVIOUS</li>
      <li>String PRINT</li>
      <li>String PROPERTIES</li>
      <li>String QUIT</li>
      <li>String REDO</li>
      <li>String REFRESH</li>
      <li>String RENAME</li>
      <li>String REVERT</li>
      <li>String SAVE</li>
      <li>String SAVE_ALL</li>
      <li>String SAVE_AS</li>
      <li>String SELECT_ALL</li>
      <li>String UNDO</li>
      <li>String UP</li>
    </ul>
  </li>
  <li>Clients should instead call getID() on the fields of the same names
    declared on ActionFactory in the org.eclipse.ui.actions package (org.eclipse.ui
    plug-in). For example, change IWorkbenchActionConstants.CUT to
    ActionFactory.CUT.getId().</li>
  <li>The following fields were removed (deprecated) from this interface because
    they were IDE-specific.
    <ul>
      <li>String ADD_TASK</li>
      <li>String BOOKMARK</li>
      <li>String BUILD</li>
      <li>String BUILD_PROJECT</li>
      <li>String CLOSE_PROJECT</li>
      <li>String FIND</li>
      <li>String OPEN_PROJECT</li>
      <li>String REBUILD_ALL</li>
      <li>String REBUILD_PROJECT</li>
    </ul>
  </li>
  <li>Clients should instead call getID() on the fields of the same names
    declared on IDEActionFactory in the org.eclipse.ui.ide package (org.eclipse.ui.ide
    plug-in). For example, change IWorkbenchActionConstants.BUILD to
    IDEActionFactory.BUILD.getId().</li>
</ul>
<h4>IWorkbenchPreferenceConstants (package org.eclipse.ui)</h4>
<ul>
  <li>The following fields were removed (deprecated) from this interface because
    they were IDE-specific:
    <ul>
      <li>String PROJECT_OPEN_NEW_PERSPECTIVE</li>
    </ul>
  </li>
  <li>Clients should instead use the fields of the same names declared on
    IDE.Preferences in the org.eclipse.ui.ide package.</li>
</ul>
<h4>IExportWizard (package org.eclipse.ui)</h4>
<ul>
  <li>Prior to 3.0, the selection passed to IWorkbenchWizard.init(IWorkbench,
    IStructuredSelection) for an export wizard was preprocessed. If any of the
    selections were IResources, or adaptable to IResource, then the selection
    consisted only of these resources. In 3.0, the generic export wizard does
    not do any preprocessing.&nbsp;</li>
  <li>The selection passed to the wizard is generally used to prime the
    particular wizard page with contextually appropriate values.</li>
  <li>Client that implement IExportWizard and requires this resource-specific
    selection transformation should add the following to their init(IWorkbench,
    IStructuredSelection selection) method to computer <code>filteredSelection</code>
    from <code>selection</code>:
    <ul>
      <li><code>IStructuredSelection filteredSelection = selection;<br>
        List selectedResources = IDE.computeSelectedResources(currentSelection);<br>
        if (!selectedResources.isEmpty()) {<br>
        &nbsp;&nbsp;&nbsp; filteredSelection = new
        StructuredSelection(selectedResources);<br>
        }</code></li>
    </ul>
  </li>
</ul>
<h4>IImportWizard (package org.eclipse.ui)</h4>
<ul>
  <li>Prior to 3.0, the selection passed to IWorkbenchWizard.init(IWorkbench,
    IStructuredSelection) for an import wizard was preprocessed. If any of the
    selections were IResources, or adaptable to IResource, then the selection
    consisted only of these resources. In 3.0, the generic import wizard does
    not do any preprocessing.&nbsp;</li>
  <li>The selection passed to the wizard is generally used to prime the
    particular wizard page with contextually appropriate values.</li>
  <li>Client that implement IImportWizard and requires this resource-specific
    selection transformation should add the following to their init(IWorkbench,
    IStructuredSelection selection) method to compute a filtered selection from
    the selection passed in:
    <ul>
      <li><code>IStructuredSelection filteredSelection = selection;<br>
        List selectedResources = IDE.computeSelectedResources(currentSelection);<br>
        if (!selectedResources.isEmpty()) {<br>
        &nbsp;&nbsp;&nbsp; filteredSelection = new
        StructuredSelection(selectedResources);<br>
        }</code></li>
    </ul>
  </li>
</ul>
<h4>INewWizard (package org.eclipse.ui)</h4>
<ul>
  <li>Prior to 3.0, the selection passed to IWorkbenchWizard.init(IWorkbench,
    IStructuredSelection) for a new wizard was preprocessed. If there was no
    structured selection at the time the wizard was invoked, but the active
    workbench window had an active editor open on an IFile, then the selection
    passed in would consist of that IFile. In 3.0, the generic new wizard does
    not do any preprocessing, and an empty selection will be passed when there
    is no structured selection.</li>
  <li>The selection passed to the wizard is generally used to prime the
    particular wizard page with contextually appropriate values.</li>
  <li>Client that implement INewWizard and requires this capability should add
    the following to their init(IWorkbench, IStructuredSelection selection)
    method to compute a selection from the active editor's input:
    <pre>if (selection.isEmpty()) {
   IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
   if (window != null) {
      IWorkbenchPart part = window.getPartService().getActivePart();
      if (part instanceof IEditorPart) {
         IEditorInput input = ((IEditorPart) part).getEditorInput();
         if (input instanceof IFileEditorInput) {
            selection = new StructuredSelection(((IFileEditorInput) input).getFile());
         }
      }		
  }
}</pre>
  </li>
</ul>
<h4>WorkbenchHelp (package org.eclipse.ui.help)</h4>
<ul>
  <li>The following WorkbenchHelp method was removed (deprecated) from this
    class because its result (IHelp) was removed (deprecated):
    <ul>
      <li>public static IHelp getHelpSupport()</li>
    </ul>
  </li>
  <li>Clients that called this method to obtain an IHelp should instead call the
    static methods on HelpSystem or WorkbenchHelp.</li>
</ul>
<h4>IHelp (package org.eclipse.help)</h4>
<ul>
  <li>This interface has been removed (deprecated). WorkbenchHelp.getHelpsupport()
    was the only way to get hold of an IHelp object. This method has also been
    removed (deprecated).</li>
  <li>The following IHelp methods now appear as static methods on a new
    HelpSystem class in the same package:
    <ul>
      <li>public IToc[] getTocs()</li>
      <li>public IContext getContext(String contextId)</li>
    </ul>
  </li>
  <li>The rest of the IHelp methods now appear as static method on WorkbenchHelp.</li>
  <li>This interface was formerly mentioned in the contract for the
    org.eclipse.help.support extension point. This extension point has been
    renamed &quot;org.eclipse.ui.helpSupport&quot;, and the contract simplified
    so that the implementer only needs supply the display methods. For these
    purposes, IHelp has been replaced by AbstractHelpUI (in the
    org.eclipse.ui.help package).</li>
  <li>There should be no clients implementing this interface beyond the Platform
    which supplied the sole implementation of this interface.</li>
</ul>
<h4>ITextEditorActionConstants (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>This interface additionally includes newly defined constants that redefine
    deprecated constants inherited from org.eclipse.ui.IWorkbenchActionConstants.
    This change allows clients to free their code from deprecation warnings. The
    constants ADD_TASK and BOOKMARK have not been redefined as they are IDE
    specific. When using these two constants in your code, please follow the
    instructions given in the deprecation message.</li>
</ul>
<h4>IAbstractTextEditorHelpContextIds (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>BOOKMARK_ACTION and ADD_TASK_ACTION have been deprecated because they are
    IDE specific. Use the constants defined in
    org.eclipse.ui.editors.text.ITextEditorHelpContextIds instead.</li>
</ul>
<h4>BasicTextEditorActionContributor (package org.eclipse.ui.texteditor)</h4>
<ul>
  <li>BasicTextEditorActionContributor no longer assigns any editor action as
    global action for org.eclipse.ui.IWorkbenchActionConstants.ADD_TASK and
    org.eclipse.ui.IWorkbenchActionConstants.BOOKMARK because these actions are
    IDE specific. This is now done by the
    org.eclipse.ui.editors.text.TextEditorActionContributor. If your editors are
    not configured to used TextEditorActionContributor but uses a contributor
    that is a subclass of BasicTextEditorActionContributor, this contributor has
    to be extended to also assign global action handlers for ADD_TASK and
    BOOKMARK. This can be done by adding the following lines to the
    setActiveEditor method of the editor action contributor:</li>
  <li>
    <pre> IActionBars actionBars= getActionBars();
 if (actionBars != null) {
   actionBars.setGlobalActionHandler(IDEActionFactory.ADD_TASK.getId(), getAction(textEditor, IDEActionFactory.ADD_TASK.getId()));
   actionBars.setGlobalActionHandler(IDEActionFactory.BOOKMARK.getId(), getAction(textEditor, IDEActionFactory.BOOKMARK.getId()));
 }</pre>
  </li>
</ul>
<h4>TextEditorActionContributor (package org.eclipse.ui.editors.text)</h4>
<ul>
  <li>TextEditorActionContributor assigns global action handlers for
    IWorkbenchActionConstants.ADD_TASK (now IDEActionFactory.ADD_TASK.getId())
    and IWorkbenchActionConstants.BOOKMARK (now IDEActionFactory.BOOKMARK.getId()).
    These action handlers have previously been registered by
    BasicTextEditorActionContributor. See migration notes for
    BasicTextEditorActionContributor.</li>
</ul>
<h4>ILaunchConfigurationType (package org.eclipse.debug.core)</h4>
<p>With the introduction of extensible launch modes in 3.0, more than one launch
delegate can exist for a launch configuration type. Releases prior to 3.0 only
supported one launch delegate per launch configuration type. The method <code>ILaunchConfigurationType.getDelegate()</code>
is now deprecated. The method <code>getDelegate(String mode)</code> should be
used in its place to retrieve the launch delegate for a specific launch mode.
The deprecated method has been changed to return the launch delegate for the <code>run</code>
mode.</p>
<h4>ILaunchConfigurationTab and ILaunchConfigurationTabGroup (package
org.eclipse.debug.ui)</h4>
<p>Launch tab groups and launch tabs are no longer notified when a launch
completes. The method <code>launched(ILaunch)</code> in the interfaces <code>ILaunchConfigurationTab</code>
and <code>ILaunchConfigurationTabGroup</code> has been deprecated and is no
longer called. Relying on this method for launch function was always
problematic, since tabs only exist when launching is performed from the launch
dialog. Also, with the introduction of background launching, this method can no
longer be called, as the launch dialog is be closed before the resulting launch
object exists.</p>
<h4>ILaunchConfigurationTab and AbstractLaunchConfigurationTab (package
org.eclipse.debug.ui)</h4>
<p>Two methods have been added to the <code>ILaunchConfigurationTab</code>
interface - activated and deactivated. These new life cycle methods are called
when a tab is entered and exited respectively. Existing implementations of <code>ILaunchConfigurationTab</code>
that subclass the abstract class provided by the debug plug-in (<code>AbstractLaunchConfigurationTab</code>)
are binary compatible since the methods are implemented in the abstract class.</p>
<p>In prior releases, a tab was sent the message <code>initializeFrom</code>
when it was activated, and <code>performApply</code> when it was deactivated. In
this way, the launch configuration tab framework provided inter-tab
communication via a launch configuration (by updating the configuration with
current attribute values when a tab is exited, and updating the newly entered
tab). However, since many tabs do not perform inter-tab communication, this can
be inefficient. As well, there was no way to distinguish between a tab being
activated, and a tab displaying a selected launch configuration for the first
time. The newly added methods allow tabs to distinguish between activation and
initialization, and deactivation and saving current values.</p>
<p>The default implementation of <code>activated</code>, provided by the
abstract tab, calls <code>initializeFrom</code>. And, the default implementation
of <code>deactivated</code> calls <code>performApply</code>. Tabs wishing to
take advantage of the new API should override these methods as required.
Generally, for tabs that do not perform inter-tab communication, the recommended
approach is to re-implement these methods to do nothing.</p>
<h4>launchConfigurationTabGroup extension point Type (package
org.eclipse.debug.ui)</h4>
<p>In prior releases, perspective switching was specified on a launch
configuration, via the launch configuration attributes <code>ATTR_TARGET_DEBUG_PERSPECTIVE</code>
and <code>ATTR_TARGET_RUN_PERSPECTIVE</code>. With the addition of extensible
launch modes in 3.0, this approach no longer scales. Perspective switching is
now specified on launch configuration type basis, per launch mode that a launch
configuration type supports. API has been added to <code>DebugUITools</code> to
set and get the perspective associated with a launch configuration type for a
specific launch mode.</p>
<p>An additional, optional, <code>launchMode</code> element has been added to
the <code>launchConfigurationTabGroup</code> extension point, allowing a
contributed tab group to specify a default perspective for a launch
configuration type and mode.</p>
<p>From the Eclipse user interface, users can edit the perspective associated
with a launch configuration type by opening the launch configuration dialog, and
selecting a launch configuration type node in the tree (rather than an
individual configuration). A tab is displayed allowing the user to set a
perspective with each supported launch mode.</p>
<h4>[JDT only] IVMRunner (package org.eclipse.jdt.launching)</h4>
<p>Two methods have been added to the <code>VMRunnerConfiguration</code> class
to support the setting and retrieving of environment variables. Implementors of <code>IVMRunner</code>
should call <code>VMRunnerConfiguration.getEnvironment()</code> and pass that
environment into the executed JVM. Clients who use <code>DebugPlugin.exec(String[]
cmdLine, File workingDirectory)</code> can do this by calling <code>DebugPlugin.exec(String[]
cmdLine, File workingDirectory, String[] envp)</code> instead. Simply passing in
the result from <code>getEnvironment()</code> is sufficient.</p>
<h4>[JDT only] VMRunnerConfiguration and Bootstrap Classes (package
org.eclipse.jdt.launching)</h4>
<p>In prior releases, the <code>VMRunnerConfiguration</code> had one attribute
to describe a boot path. The attribute is a collection of <code>Strings</code>
to be specified in the -<code>Xbootclasspath</code> argument. Three new
attributes have been added to the VMRunnerConfiguration to support JVMs that
allow for prepending and appending to the boot path. The new methods/attributes
added are:</p>
<ul>
  <li><code>getPrependBootClassPath()</code> - returns a collection of entries
    to be prepended to the boot path (the <code>-Xbootclasspath/p</code>
    argument)
  <li><code>getMainBootClassPath()</code> - returns a collection of entries to
    be placed on the boot path (the <code>-Xbootclasspath</code> argument)
  <li><code>getAppendBootClassPath()</code> - returns a collection of entries to
    be appended to the boot path (the <code>-Xbootclasspath/a</code> argument)</li>
</ul>
<p>The old attribute,<code> getBootClassPath()</code>, still exists and contains
a complete path equivalent to that of the three new attributes. However, <code>VMRunners</code>
that support the new boot path options should take advantage of the new
attributes.</p>
<h3>[JDT only] Improved support for working copies (package org.eclipse.jdt.core)</h3>
<p>The Java model working copy facility has been reworked in 3.0 to provide
greatly increased functionality. Prior to 3.0, the Java model allowed creation
of individual working copies of compilation units. Changes could be made to the
working copy and later committed. There was support for limited analysis of a
working copy in the context of the rest of the Java model. However, there was no
way these these analyses could ever take into account more than one of the
working copies at a time.</p>
<p>The changes in 3.0 make it possible to create and manage sets of working
copies of compilation units, and to perform analyses in the presence of all
working copies in a set. For example, it is now possible for a client like JDT
refactoring to create working copies for one or more compilation units that it
is considering modifying and then to resolve type references between the working
copies. Formerly this was only possible after the changes to the compilation
unit working copies had been committed.</p>
<p>The Java model API changes in 2 ways to add this improved support:</p>
<p>(1) The functionality formerly found on <code>IWorkingCopy</code> and
inherited by <code>ICompilationUnit</code> has been consolidated into <code>ICompilationUnit</code>.
The <code>IWorkingCopy</code> interface was only used in this one place, and was
gratuitously more general that in needed to be. This change simplifies the API. <code>IWorkingCopy</code>
has been deprecated. Other places in the API where <code>IWorkingCopy</code> is
used as a parameter or result type have been deprecated as well; the replacement
API methods mention <code>ICompilationUnit</code> instead of <code>IWorkingCopy</code>.</p>
<p>(2) The interface <code>IBufferFactory</code> has been replaced by <code>WorkingCopyOwner</code>.
The improved support for working copies requires that there be an object to own
the working copies. Although <code>IBufferFactory</code> is in the right place,
the name does not adequately convey how the new working copy mechanism works. <code>WorkingCopyOwner</code>
is much more suggestive. In addition, <code>WorkingCopyOwner</code> is declared
as an abstract class, rather than as an interface, to allow the notion of
working copy owner to evolve in the future. The one method on <code>IBufferFactory</code>
moves to <code>WorkingCopyOwner</code> unaffected. <code>WorkingCopyOwner</code>
does not implement <code>IBufferFactory</code> to make it clear that <code>IBufferFactory</code>
is a thing of the past. <code>IBufferFactory</code> has been deprecated. Other
places in the API where <code>IBufferFactory</code> appears as a parameter or
result type have been deprecated as well; the replacement API methods mention <code>WorkingCopyOwner</code>
instead of <code>IBufferFactory</code>.</p>
<p>These changes do not break binary compatibility.</p>
<p>When migrating, all references to the type <code>IWorkingCopy</code> should
instead reference <code>ICompilationUnit</code>. The sole implementation of <code>IWorkingCopy</code>
implements <code>ICompilationUnit</code> as well, meaning objects of type <code>IWorkingCopy</code>
can be safely cast to <code>ICompilationUnit</code>.</p>
<p>A class that implements <code>IBufferFactory</code> will need to replaced by
a subclass of <code>WorkingCopyOwner</code>. Although <code>WorkingCopyOwner</code>
does not implement <code>IBufferFactory</code> itself, it would be possible to
declare the subclass of <code>WorkingCopyOwner</code> that implements <code>IBufferFactory</code>
thereby creating a bridge between old and new (<code>IBufferFactory</code>
declares <code>createBuffer(IOpenable)</code> whereas <code>WorkingCopyOwner</code>
declares <code>createBuffer(ICompilationUnit)</code>; <code>ICompilationUnit</code>
extends <code>IOpenable</code>).</p>
<p>Because the changes involving <code>IWorkingCopy</code> and <code>IBufferFactory</code>
are interwined, we recommend dealing with both at the same time. The details of
the deprecations are as follows:</p>
<ul>
  <li><code>IWorkingCopy</code> (package <code>org.eclipse.jdt.core</code>)
    <ul>
      <li><code>public void commit(boolean, IProgressMonitor)</code> has been
        deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public void commitWorkingCopy(boolean, IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.commit(b,monitor)</code> as <code>((ICompilationUnit)
            wc).commitWorkingCopy(b,monitor)</code></li>
        </ul>
      </li>
      <li><code>public void destroy()</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public void discardWorkingCopy(boolean, IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.destroy()</code> as <code>((ICompilationUnit)
            wc).discardWorkingCopy()</code></li>
        </ul>
      </li>
      <li><code>public IJavaElement findSharedWorkingCopy(IBufferFactory)</code>
        has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public ICompilationUnit findWorkingCopy(WorkingCopyOwner)</code></li>
            </ul>
          </li>
          <li>Note: <code>WorkingCopyOwner</code> substitutes for <code>IBufferFactory.</code></li>
        </ul>
      </li>
      <li><code>public IJavaElement getOriginal(IJavaElement)</code> has been
        deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>IJavaElement</code>:
            <ul>
              <li><code>public IJavaElement getPrimaryElement()</code></li>
            </ul>
          </li>
        </ul>
        <ul>
          <li>Rewrite <code>wc.getOriginal(elt)</code> as <code>elt.getPrimaryElement()</code></li>
          <li>Note: Unlike <code>IWorkingCopy.getOriginal</code>, <code>IJavaElement.getPrimaryElement</code>
            does not return <code>null</code> if the receiver is not a working
            copy.</li>
        </ul>
      </li>
      <li><code>public IJavaElement getOriginalElement()</code> has been
        deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public ICompilationUnit getPrimary()</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.getOriginalElement()</code> as <code>((ICompilationUnit)
            wc).getPrimary()</code></li>
          <li>Note: Unlike <code>IWorkingCopy.getOriginalElement</code>, <code>IWorkingCopy.getPrimary</code>
            does not return <code>null</code> if the receiver is not a working
            copy.</li>
        </ul>
      </li>
      <li><code>public IJavaElement[] findElements(IJavaElement)</code> has been
        deprecated.
        <ul>
          <li>The method is now declared on <code>ICompilationUnit</code>
            directly.</li>
          <li>Rewrite <code>wc.findElements(elts)</code> as <code>((ICompilationUnit)
            wc).findElements(elts)</code></li>
        </ul>
      </li>
      <li><code>public IType findPrimaryType()</code> has been deprecated.
        <ul>
          <li>The method is now declared on <code>ICompilationUnit</code>
            directly.</li>
          <li>Rewrite <code>wc.findPrimaryType()</code> as <code>((ICompilationUnit)
            wc).findPrimaryType()</code></li>
        </ul>
      </li>
      <li><code>public IJavaElement getSharedWorkingCopy(IProgressMonitor,
        IBufferFactory, IProblemRequestor)</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public ICompilationUnit getWorkingCopy(WorkingCopyOwner,
                IProblemRequestor, IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Note: the parameter order has changed, and <code>WorkingCopyOwner</code>
            substitutes for <code>IBufferFactory.</code></li>
        </ul>
      </li>
      <li><code>public IJavaElement getWorkingCopy()</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public ICompilationUnit getWorkingCopy(IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.getWorkingCopy() </code>as <code>((ICompilationUnit)
            wc).getWorkingCopy(null)</code></li>
        </ul>
      </li>
      <li><code>public IJavaElement getWorkingCopy(IProgressMonitor,
        IBufferFactory, IProblemRequestor)</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public ICompilationUnit getWorkingCopy(WorkingCopyOwner,
                IProblemRequestor, IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Note: the parameter order has changed, and <code>WorkingCopyOwner</code>
            substitutes for <code>IBufferFactory.</code></li>
        </ul>
      </li>
      <li><code>public boolean isBasedOn(IResource)</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public boolean hasResourceChanged()</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.isBasesOn(res)</code> as <code>((ICompilationUnit)
            wc).hasResourceChanged()</code></li>
        </ul>
      </li>
      <li><code>public boolean isWorkingCopy()</code> has been deprecated.
        <ul>
          <li>The method is now declared on <code>ICompilationUnit</code>
            directly.</li>
          <li>Rewrite <code>wc.isWorkingCopy()</code> as <code>((ICompilationUnit)
            wc).isWorkingCopy()</code></li>
        </ul>
      </li>
      <li><code>public IMarker[]&nbsp; reconcile()</code> has been deprecated.
        <ul>
          <li>The equivalent functionality is now provided on <code>ICompilationUnit</code>
            directly:
            <ul>
              <li><code>public void reconcile(boolean,IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Rewrite <code>wc.reconcile()</code> as <code>((ICompilationUnit)
            wc).reconcile(false, null)</code></li>
          <li>Note: The former method always returned <code>null</code>; the
            replacement method does not return a result.</li>
        </ul>
      </li>
      <li><code>public void reconcile(boolean, IProgressMonitor)</code> has been
        deprecated.
        <ul>
          <li>The method is now declared on <code>ICompilationUnit</code>
            directly.</li>
          <li>Rewrite <code>wc.reconcile(b,monitor)</code> as <code>((ICompilationUnit)
            wc).reconcile(b.monitor)</code></li>
        </ul>
      </li>
      <li><code>public void restore()</code> has been deprecated.
        <ul>
          <li>The method is now declared on <code>ICompilationUnit</code>
            directly.</li>
          <li>Rewrite <code>wc.restore()</code> as <code>((ICompilationUnit)
            wc).restore()</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code>IType</code> (package <code>org.eclipse.jdt.core</code>)
    <ul>
      <li><code>public ITypeHierarchy newSupertypeHierarchy(IWorkingCopy[],
        IProgressMonitor)</code> has been deprecated.
        <ul>
          <li>The replacement method is provided on the same class:
            <ul>
              <li><code>public ITypeHierarchy newSupertypeHierarchy(c,
                IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Note: The Java language rules for array types preclude casting <code>IWorkingCopy[]</code>
            to <code>ICompilationUnit[]</code>.</li>
        </ul>
      </li>
      <li><code>public ITypeHierarchy newTypeHierarchy(IWorkingCopy[],
        IProgressMonitor)</code> has been deprecated.
        <ul>
          <li>The replacement method is provided on the same class:
            <ul>
              <li><code>public ITypeHierarchy newTypeHierarchy(ICompilationUnit[],
                IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Note: The Java language rules for array types preclude casting <code>IWorkingCopy[]</code>
            to <code>ICompilationUnit[]</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code>IClassFile</code> (package <code>org.eclipse.jdt.core</code>)
    <ul>
      <li><code>public IJavaElement getWorkingCopy(IProgressMonitor,
        IBufferFactory)</code> has been deprecated.
        <ul>
          <li>The replacement method is provided on the same class:
            <ul>
              <li><code>public ICompilationUnit getWorkingCopy(WorkingCopyOwner,
                IProgressMonitor)</code></li>
            </ul>
          </li>
          <li>Note: the parameter order has changed, and <code>WorkingCopyOwner</code>
            substitutes for <code>IBufferFactory.</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code>JavaCore</code> (package <code>org.eclipse.jdt.core</code>)
    <ul>
      <li><code>public IWorkingCopy[] getSharedWorkingCopies(IBufferFactory)</code>
        has been deprecated.
        <ul>
          <li>The replacement method is provided on the same class:
            <ul>
              <li><code>public ICompilationUnit[]
                getWorkingCopies(WorkingCopyOwner)</code></li>
            </ul>
          </li>
          <li>Note: <code>WorkingCopyOwner</code> substitutes for <code>IBufferFactory.</code></li>
          <li>Note: The Java language rules for array types preclude casting <code>ICompilationUnit[]</code>
            to <code>IWorkingCopy[]</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code>SearchEngine</code> (package <code>org.eclipse.jdt.core.search</code>)
    <ul>
      <li><code>public SearchEngine(IWorkingCopy[])</code> has been deprecated.
        <ul>
          <li>The replacement constructor is provided on the same class:
            <ul>
              <li><code>public SearchEngine(ICompilationUnit[])</code></li>
            </ul>
          </li>
          <li>Note: The Java language rules for array types preclude casting <code>IWorkingCopy[]</code>
            to <code>ICompilationUnit[]</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3>Restructuring of org.eclipse.help plug-in</h3>
<p>The org.eclipse.help plug-in, which used to hold APIs and extension points
for contributing to and extending help system, as well as displaying help, now
contains just APIs and extension points for contributing and accessing help
resources. A portion of default help UI implementation contained in that plug-in
has been moved to a new plug-in org.eclipse.help.base together with APIs for
extending the implementation. The APIs and extension point for contributing Help
UI and displaying help have been moved to org.eclipse.ui plug-in. This
restructuring allows applications greater flexibility with regard to the help
system; the new structure allows applications based on the generic workbench to
provide their own Help UI and/or Help implementation, or to omit the help system
entirely.</p>
<p>Because the extension points and API packages affected are intended only for
use by the help system itself, it is unlikely that existing plug-ins are
affected by this change. They are included here only for the sake of
completeness:</p>
<ul>
  <li>API packages org.eclipse.ui.help.browser and
    org.eclipse.ui.help.standalone, formerly provided by the org.eclipse.help
    plug-in, have been moved to the org.eclipse.help.base plug-in.</li>
  <li>Extension points org.eclipse.help.browser, org.eclipse.help.luceneAnalyzer,
    and org.eclipse.help.webapp, formerly defined by the org.eclipse.help
    plug-in, have been moved to the org.eclipse.help.base plug-in, with a
    corresponding change in extension point id.</li>
  <li>Extension point org.eclipse.help.support has been replaced by the
    org.eclipse.ui.helpSupport extension point. The contract for this extension
    point changed as well (see entry for IHelp).</li>
</ul>
<h3>null messages in MessageBox and DirectoryDialog (package
org.eclipse.swt.widgets)</h3>
<p>Prior to 3.0, calling SWT's DirectoryDialog.setMessage(String string) or
MessageBox.setMessage(String string) with a null value for string would result
in a dialog with no text in the title. This behavior was unspecified (passing
null has never been permitted) and creates problems with getMessage which is not
permitted to return null. In 3.0, passing null now results in an
IllegalArgumentException exception being thrown, and the specifications have
been changed to state this, bringing it into line with the method on their
superclass Dialog.setMessage. If you use Dialog.setMessage, ensure that that the
string passed in is never null. Simply pass an empty string if you want a dialog
with no text in the title.</p>
<h3>Improving modal progress feedback</h3>
<p>Supporting concurrent operations requires more sophisticated ways to show
modal progress. As part of the responsiveness effort additional progress support
was implemented in the class IProgressService. The existing way to show progress
with the ProgressMonitorDialog is still working. However, to improve the user
experience we recommend migrating to the new IProgressService.</p>
<p>The document <a href="http://dev.eclipse.org/viewcvs/index.cgi/~checkout~/platform-core-home/documents/plan_concurrency_modal_progress.html">Showing
Modal Progress in Eclipse 3.0</a> describes how to migrate to the new
IProgressService.</p>
<h3>Debug Action Groups removed</h3>
<p>The Debug Action Groups extension point
(org.eclipse.debug.ui.debugActionGroups) has been removed. In Eclipse 3.0, the
workbench introduced support for Activities via the
org.eclipse.platform.ui.activities extension point. This support provides
everything that Debug Action Groups provided and is also easier to use (it
supports patterns instead of specifying all actions exhaustively) and has a
programmatic API to support it. Failing to remove references to the old
extension point won't cause any failures. References to the extension point will
simply be ignored. Product vendors are encouraged to use the workbench
Activities support to associate language-specific debugger actions with
language-specific activities (for example, C++ debugging actions might be
associated with an activity called &quot;Developing C++&quot;).</p>
<h3>BreakpointManager can be disabled</h3>
<p>IBreakpointManager now defines the methods setEnabled(boolean) and
isEnabled(). When the breakpoint manager is disabled, debuggers should ignore
all registered breakpoints. The debug platform also provides a new listener
mechanism, IBreakpointManagerListener which allows clients to register with the
breakpoint manager to be notified when its enablement changes. The Breakpoints
view calls this API from a new toggle action that allows the user to &quot;Skip
All Breakpoints.&quot; Debuggers which do not honor the breakpoint manager's
enablement will thus appear somewhat broken if the user tries to use this
feature.</p>
<h2><a name="PDE Plug-in Migration Tool">PDE Plug-in Migration Tool</a></h2>
<p>PDE provides a special wizard for converting 2.1 plug-in manifest to 3.0,
found at <b>PDE Tools &gt; Migrate to 3.0</b>. on the context menu for the
selected plugin.xml or fragment.xml file. In addition to adding &lt;?eclipse
...?&gt; line, this migration tool also fixes up references to the extension
points that have been renamed and changes the plug-ins dependencies list to
reflect the Platform restructuring.</p>
<h2><a name="General Information on Compatibility">General Information on
Compatibility</a></h2>
<p>Eclipse 3.0 is not fully compatible with 2.0 and 2.1. The nature and scope of
some of the key 3.0 plan items were such that the only feasible solutions break
compatibility. The decision to make these breaking changes was done after open
discussion with the community. That said, most of the Eclipse APIs are the same
in 3.0 as in 2.1 and 2.0. We have only broken APIs in 3.0 when there is a
compelling case for doing so, and have tried to do it in a controlled way that
minimizes the effort required to port an existing plug-in to the 3.0 APIs.
Furthermore, in order to ensure that existing 2.1 binary plug-ins in the field
continue to run with 3.0 despite these breaking change, we have included
additional runtime compatibility mechanisms to provide effective binary API
compatibility.</p>
<p><b>API Contract Compatibility:</b> Eclipse SDK 3.0 is upwards
contract-compatible with Eclipse SDK 2.0 and 2.1 except in those areas noted in
this document. Programs that use affected APIs and extension points will need to
be ported to Eclipse SDK 3.0 APIs (API is construed broadly to include such
things as plug-in extension points.) Downward contract compatibility is not
supported. There is no guarantee that compliance with Eclipse SDK 3.0 APIs would
ensure compliance with Eclipse SDK 2.0 or 2.1 APIs. Refer to <i><a href="http://eclipse.org/eclipse/development/java-api-evolution.html">Evolving
Java-based APIs</a></i> for a discussion of the kinds of API changes that
maintain contract compatibility.
<p><b>Binary (plug-in) Compatibility:</b> Eclipse SDK 3.0 is upwards
binary-compatible with Eclipse SDK 2.0 and 2.1 except in those areas noted in
this document. Eclipse 3.0 includes additional runtime compatibility mechanisms
to provide effective binary API compatibility. For cases not covered by these
runtime compatibility mechanisms, plug-ins that use affected APIs and extension
points will need to be ported and recompiled for Eclipse SDK 3.0. Downward
plug-in compatibility is not supported either. Plug-ins for Eclipse SDK 3.0 will
not be usable in Eclipse SDK 2.0 or 2.1. Refer to <i><a href="http://eclipse.org/eclipse/development/java-api-evolution.html">Evolving
Java-based APIs</a></i> for a discussion of the kinds of API changes that
maintain binary compatibility.
<p><b>Source Compatibility:</b> Eclipse SDK 3.0 is upwards source-compatible
with Eclipse SDK 2.0 or 2.1 except in the areas noted in this document. This
means that source files written to use Eclipse SDK 2.0 or 2.1 APIs might
successfully compile and run against Eclipse SDK 3.0 APIs, although this is not
guaranteed. Downward source compatibility is not supported. If source files use
new Eclipse SDK APIs, they will not be usable with an earlier version of the
Eclipse SDK.
<p><b>Workspace Compatibility:</b> Eclipse SDK 3.0 is upwards
workspace-compatible with Eclipse SDK 2.0 or 2.1 unless noted. This means that
workspaces and projects created with Eclipse SDK 2.0 or 2.1 can be successfully
opened by Eclipse SDK 3.0 and upgraded to a 3.0 workspace. This includes both
hidden metadata, which is localized to a particular workspace, as well as
metadata files found within a workspace project (e.g., the .project file), which
may propagate between workspaces via file copying or team repositories.
Individual plug-ins developed for Eclipse SDK 3.0 should provide similar upwards
compatibility for their hidden and visible workspace metadata created by earlier
versions; 3.0 plug-in developers are responsible for ensuring that their
plug-ins recognize 3.0, 2.1, and 2.0 metadata and process it appropriately. User
interface session state may be discarded when a workspace is upgraded. Downward
workspace compatibility is not supported. A workspace created (or opened) by
Eclipse SDK 3.0 will be unusable with an earlier version of Eclipse
SDK.&nbsp;Visible metadata files created (or overwritten) by Eclipse SDK 3.0
will generally be unusable with earlier versions of Eclipse SDK.
<p><b>Non-compliant usage of API's</b>: All non-API methods and classes, and
certainly everything in a package with &quot;internal&quot; in its name, are
considered implementation details which may vary between operating environment
and are subject to change without notice. Client plug-ins that directly depend
on anything other than what is specified in the Eclipse SDK API are inherently
unsupportable and receive no guarantees about compatibility within a single
release much less with an earlier releases. Refer to <i><a href="http://www.eclipse.org/articles/Article-API%20use/eclipse-api-usage-rules.html">How
to Use the Eclipse API</a></i> for information about how to write compliant
plug-ins. This porting guide does not cover non-API methods and classes.</p>
<p><a href="../hglegal.htm"><img src="../cpy.gif" alt="Copyright IBM Corporation and others 2000, 2004." border="0" width="250" height="12"></a></p>

</body>

</html>
