<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Memory Rendering Types</title>
<style>@import url("../../book.css");</style>
<style>@import url("../../schema.css");</style>
</HEAD>
<BODY>
<H1><CENTER>Memory Rendering Types</CENTER></H1>
<p></p>
<h6 class=CaptionFigColumn id=header>Identifier: </h6>org.eclipse.debug.ui.memoryRenderingTypes<p></p>
<h6 class=CaptionFigColumn id=header>Since: </h6>Eclipse 3.1
<p></p>

<p>
<h6 class=CaptionFigColumn id=header>Description: </h6>Allows plug-ins to contribute renderings for memory blocks. A rendering translates raw bytes of a memory block into text that can be displayed in the memory view. The debug platform provides a set of memory renderings (HEX, ASCII, Signed Integer and Unsigned Integer). NOTE: this extension point was provided in the 3.0 release as experimental API, subject to change, and became public API in the 3.1 release.<p>
<p>
</p>
<p><h6 class=CaptionFigColumn id=header>Configuration Markup:</h6></p>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.rendering">rendering</a>* | <a href="#e.renderingBinding">renderingBinding</a>* | <a href="#e.defaultRenderings">defaultRenderings</a>* | <a href="#e.viewBinding">viewBinding</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.rendering">rendering</a> (<a href="#e.renderingProperty">renderingProperty</a>* , <a href="#e.viewBinding">viewBinding</a>+)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST rendering</p>
<p class=code id=dtdAttlist>renderingId&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>renderingFactory&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element defines a rendering.  A rendering is comprised of an id, a name, an optional rendering factory, and an optional list of rendering properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingId</b> - unique identifier for this rendering</li>
<li><b>name</b> - human-readable name of this rendering</li>
<li><b>renderingFactory</b> - requied fully qualified name of the Java class that implements <code>org.eclipse.debug.core.memory.IMemoryRenderingFactory</code>.  When unspecified, a default rendering factory will be used.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingProperty">renderingProperty</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingProperty</p>
<p class=code id=dtdAttlist>name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>renderingId&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Specifies rendering specific properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>name</b> - name of this property</li>
<li><b>value</b> - value of this property</li>
<li><b>renderingId</b> - rendering id of the rendering type that this property is associated with.  If not specified, the rendering manager tries to determine the rendering id from the property's parent configuration element.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingBinding">renderingBinding</a> (<a href="#e.enablement">enablement</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingBinding</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Binds a type of memory block with available renderings.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of memory renderings available for the associated type of memory block</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.defaultRenderings">defaultRenderings</a> (<a href="#e.enablement">enablement</a>+)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST defaultRenderings</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Specifies the default renderings to create for a specific type of memory block.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of of memory renderings to be created by default for memory blocks of the associated type.  Memory renderings are specified via their <code>renderingId</code>. An equivalent rendering binding must exist for a default rendering to be considered.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.viewBinding">viewBinding</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST viewBinding</p>
<p class=code id=dtdAttlist>renderingId&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>viewIds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Define the views that are supported by the specified rendering</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingId</b> - rendering id of the rendering to bind.  If not specified, the rendering manager tries to retrieve the rendering id from its parent's configuration element.</li>
<li><b>viewIds</b> - views ids of the views supported by the specified rendering type</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.rendering">rendering</a>* | <a href="#e.renderingBinding">renderingBinding</a>* | <a href="#e.defaultRenderings">defaultRenderings</a>* | <a href="#e.viewBinding">viewBinding</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.rendering">rendering</a> (<a href="#e.renderingProperty">renderingProperty</a>* , <a href="#e.viewBinding">viewBinding</a>+)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST rendering</p>
<p class=code id=dtdAttlist>renderingId&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>renderingFactory&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element defines a rendering.  A rendering is comprised of an id, a name, an optional rendering factory, and an optional list of rendering properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingId</b> - unique identifier for this rendering</li>
<li><b>name</b> - human-readable name of this rendering</li>
<li><b>renderingFactory</b> - requied fully qualified name of the Java class that implements <code>org.eclipse.debug.core.memory.IMemoryRenderingFactory</code>.  When unspecified, a default rendering factory will be used.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingProperty">renderingProperty</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingProperty</p>
<p class=code id=dtdAttlist>name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>renderingId&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Specifies rendering specific properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>name</b> - name of this property</li>
<li><b>value</b> - value of this property</li>
<li><b>renderingId</b> - rendering id of the rendering type that this property is associated with.  If not specified, the rendering manager tries to determine the rendering id from the property's parent configuration element.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingBinding">renderingBinding</a> (<a href="#e.enablement">enablement</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingBinding</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Binds a type of memory block with available renderings.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of memory renderings available for the associated type of memory block</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.defaultRenderings">defaultRenderings</a> (<a href="#e.enablement">enablement</a>+)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST defaultRenderings</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Specifies the default renderings to create for a specific type of memory block.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of of memory renderings to be created by default for memory blocks of the associated type.  Memory renderings are specified via their <code>renderingId</code>. An equivalent rendering binding must exist for a default rendering to be considered.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.viewBinding">viewBinding</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST viewBinding</p>
<p class=code id=dtdAttlist>renderingId&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>viewIds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Define the views that are supported by the specified rendering</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingId</b> - rendering id of the rendering to bind.  If not specified, the rendering manager tries to retrieve the rendering id from its parent's configuration element.</li>
<li><b>viewIds</b> - views ids of the views supported by the specified rendering type</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><h6 class=CaptionFigColumn id=header>Examples: </h6>The following is an example for defining a new rendering type.

<p>
<pre>
<p class=code id=tag>&lt;extension
    id=<p class=code id=cstring>&quot;org.eclipse.debug.ui.renderings&quot;</p><p class=code id=tag>
    name=<p class=code id=cstring>&quot;Sample Rendering Type&quot;</p><p class=code id=tag>
    point=<p class=code id=cstring>&quot;org.eclipse.debug.ui.memoryRenderingTypes&quot;</p><p class=code id=tag>&gt;</p>
    <p class=code id=tag>&lt;rendering 
        name=<p class=code id=cstring>&quot;Sample Rendering&quot;</p><p class=code id=tag>
        renderingId=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>
        renderingFactory=<p class=code id=cstring>&quot;com.example.SampleRenderingsFactory&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;renderingProperty
            name=<p class=code id=cstring>&quot;viewTabFactory&quot;</p><p class=code id=tag>
            value=<p class=code id=cstring>&quot;com.example.SampleViewTabFactory&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;/renderingProperty&gt;</p>
        <p class=code id=tag>&lt;viewBinding viewIds=<p class=code id=cstring>&quot;org.eclipse.debug.ui.MemoryView.RenderingViewPane&quot;</p><p class=code id=tag>/&gt;</p>
    <p class=code id=tag>&lt;/rendering&gt;</p>        
<p class=code id=tag>&lt;/extension&gt;</p>        
</pre>
</p>

In the above example, a new rendering type, Sample Rendering, is defined. This rendering type supports the rendering view pane from the Memory View.
<br><br>
The following is an example for allowing Sample Rendering to be displayed in the rendering view pane from the Memory View.  
<p>
<pre>
<p class=code id=tag>&lt;extension
    id=<p class=code id=cstring>&quot;com.example&quot;</p><p class=code id=tag>
    name=<p class=code id=cstring>&quot;Sample Rendering Extension&quot;</p><p class=code id=tag>
    point=<p class=code id=cstring>&quot;org.eclipse.debug.ui.memoryRenderingTypes&quot;</p><p class=code id=tag>&gt;</p>
    <p class=code id=tag>&lt;renderingBinding
        renderingIds=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;enablement&gt;</p>
            <p class=code id=tag>&lt;instanceof value=<p class=code id=cstring>&quot;com.example.SampleMemoryBlock&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;/enablement&gt;</p>    
    <p class=code id=tag>&lt;/renderingBinding&gt;</p>  
    <p class=code id=tag>&lt;defaultRenderings
        renderingIds=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;enablement&gt;</p>
            <p class=code id=tag>&lt;instanceof value=<p class=code id=cstring>&quot;com.example.SampleMemoryBlock&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;/enablement&gt;</p>    
    <p class=code id=tag>&lt;/defaultRenderings&gt;</p>
<p class=code id=tag>&lt;/extension&gt;</p>  
</pre>
</p>   

In the above example, the Sample Rendering is defined as a valid rendering for SampleMemoryBlock. Whenever SampleMemoryBlock is created in the Memory View, a Sample Rendering will be created.
<p></p>

<h6 class=CaptionFigColumn id=header>API Information: </h6><p>
<li>Value of the attribute <b>renderingFactory </b> must be a fully qualifed name of a Java class that implements <b>IMemoryRenderingFactory</b>.</li>
<li>Value of the attribute <b> value </b> from the <b>viewTabFactory</b> rendering property must be a fully qualifed name of a Java class that implements <b>IMemoryViewTabFactory</b>.</li>
<li>Value of the attribute <b>instanceof</b> from the <b> enablement </b> element must be a fully qualified name of a Java class that implements the interface <b>IMemoryBlock</b>.</li>
</p>
<p></p>

<h6 class=CaptionFigColumn id=header>Supplied Implementation: </h6>The debug platform provides the following rendering types:<br>
<li>Hex Rendering (rendering id: org.eclipse.debug.ui.rendering.raw_memory)</li>
<li>ASCII Rendering (rendering id: org.eclipse.debug.ui.rendering.ascii)</li>
<li>Signed Integer Rendering (rendering id: org.eclipse.debug.ui.rendering.signedint)</li>
<li>Unsigned Integer Rendering (rendering id: org.eclipse.debug.ui.rendering.unsignedint) </li>
<p></p>

<br>
<p class=note id=copyright>
Copyright (c) 2004 IBM Corporation and others.<br>
All rights reserved. This program and the accompanying materials are made 
available under the terms of the Common Public License v1.0 which 
accompanies this distribution, and is available at 
<a href="http://www.eclipse.org/legal/cpl-v10.html">http://www.eclipse.org/legal/cpl-v10.html</a>
<p></p>

</p>
</BODY>
</HTML>
