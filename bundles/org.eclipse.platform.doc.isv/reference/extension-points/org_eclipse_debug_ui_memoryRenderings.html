<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Memory Renderings</title>
<style>@import url("../../book.css");</style>
<style>@import url("../../schema.css");</style>
</HEAD>
<BODY>
<H1><CENTER>Memory Renderings</CENTER></H1>
<p></p>
<h6 class=CaptionFigColumn id=header>Identifier: </h6>org.eclipse.debug.ui.memoryRenderings<p></p>
<h6 class=CaptionFigColumn id=header>Since: </h6>3.1 - replacement for memoryRenderingTypes extension point which was considered experimental in 3.0
<p></p>

<p>
<h6 class=CaptionFigColumn id=header>Description: </h6>Allows plug-ins to contribute arbitrary renderings for memory blocks and bind memory blocks to renderings. For example, a rendering may translate raw bytes of a memory block into ASCII characters.<p>
<p>
</p>
<p><h6 class=CaptionFigColumn id=header>Configuration Markup:</h6></p>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.renderingType">renderingType</a>* | <a href="#e.renderingBindings">renderingBindings</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingType">renderingType</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingType</p>
<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>class&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element defines a rendering.  A rendering is comprised of an id, a name, an optional rendering factory, and an optional list of rendering properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>name</b> - human-readable name of this rendering type</li>
<li><b>id</b> - unique identifier for this rendering</li>
<li><b>class</b> - fully qualified name of the Java class that implements <code>org.eclipse.debug.ui.memory.IMemoryRenderingFactory</code></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingBindings">renderingBindings</a> (<a href="#e.enablement">enablement</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingBindings</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>primaryId&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>defaultIds&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Binds memory blocks with available renderings.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of memory rendering type identifiers, specifying available rendering types for memory blocks this binding is enabled for. Must not be specified when <code>class</code> is provided.</li>
<li><b>primaryId</b> - memory rendering type identifier, specifying the default rendering type to be considered primary for memory blocks this binding is enabled for. When there is more than one default rendering type bound to a memory block, the UI may use the information to determine which rendering should be made visible (i.e the primrary one). Must not be specified when <code>class</code> is provided. Clients should be careful to specify only one primary rendering type per memory block.</li>
<li><b>class</b> - fully qualified name of the Java class that implements <code>org.eclipse.debug.ui.memory.IMemoryRenderingBindingsProvider</code>, allowing for dynamic rendering bindings. When specified, <code>renderingIds</code>, <code>defaultIds</code>, and <code>primaryId</code> must not be specified.</li>
<li><b>defaultIds</b> - comma delimited list of memory rendering type identifiers, specifying default rendering types for memory blocks this binding is enabled for. Must not be specified when <code>class</code> is provided.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.renderingType">renderingType</a>* | <a href="#e.renderingBindings">renderingBindings</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingType">renderingType</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingType</p>
<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>class&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element defines a rendering.  A rendering is comprised of an id, a name, an optional rendering factory, and an optional list of rendering properties.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>name</b> - human-readable name of this rendering type</li>
<li><b>id</b> - unique identifier for this rendering</li>
<li><b>class</b> - fully qualified name of the Java class that implements <code>org.eclipse.debug.ui.memory.IMemoryRenderingFactory</code></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.renderingBindings">renderingBindings</a> (<a href="#e.enablement">enablement</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST renderingBindings</p>
<p class=code id=dtdAttlist>renderingIds&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>primaryId&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>defaultIds&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Binds memory blocks with available renderings.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>renderingIds</b> - comma delimited list of memory rendering type identifiers, specifying available rendering types for memory blocks this binding is enabled for. Must not be specified when <code>class</code> is provided.</li>
<li><b>primaryId</b> - memory rendering type identifier, specifying the default rendering type to be considered primary for memory blocks this binding is enabled for. When there is more than one default rendering type bound to a memory block, the UI may use the information to determine which rendering should be made visible (i.e the primrary one). Must not be specified when <code>class</code> is provided. Clients should be careful to specify only one primary rendering type per memory block.</li>
<li><b>class</b> - fully qualified name of the Java class that implements <code>org.eclipse.debug.ui.memory.IMemoryRenderingBindingsProvider</code>, allowing for dynamic rendering bindings. When specified, <code>renderingIds</code>, <code>defaultIds</code>, and <code>primaryId</code> must not be specified.</li>
<li><b>defaultIds</b> - comma delimited list of memory rendering type identifiers, specifying default rendering types for memory blocks this binding is enabled for. Must not be specified when <code>class</code> is provided.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><h6 class=CaptionFigColumn id=header>Examples: </h6>The following is an example for defining a new rendering type.

<p>
<pre>
<p class=code id=tag>&lt;extension
    id=<p class=code id=cstring>&quot;org.eclipse.debug.ui.renderings&quot;</p><p class=code id=tag>
    name=<p class=code id=cstring>&quot;Sample Rendering Type&quot;</p><p class=code id=tag>
    point=<p class=code id=cstring>&quot;org.eclipse.debug.ui.memoryRenderingTypes&quot;</p><p class=code id=tag>&gt;</p>
    <p class=code id=tag>&lt;rendering 
        name=<p class=code id=cstring>&quot;Sample Rendering&quot;</p><p class=code id=tag>
        renderingId=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>
        renderingFactory=<p class=code id=cstring>&quot;com.example.SampleRenderingsFactory&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;renderingProperty
            name=<p class=code id=cstring>&quot;viewTabFactory&quot;</p><p class=code id=tag>
            value=<p class=code id=cstring>&quot;com.example.SampleViewTabFactory&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;/renderingProperty&gt;</p>
        <p class=code id=tag>&lt;viewBinding viewIds=<p class=code id=cstring>&quot;org.eclipse.debug.ui.MemoryView.RenderingViewPane&quot;</p><p class=code id=tag>/&gt;</p>
    <p class=code id=tag>&lt;/rendering&gt;</p>        
<p class=code id=tag>&lt;/extension&gt;</p>        
</pre>
</p>

In the above example, a new rendering type, Sample Rendering, is defined. This rendering type supports the rendering view pane from the Memory View.
<br><br>
The following is an example for allowing Sample Rendering to be displayed in the rendering view pane from the Memory View.  
<p>
<pre>
<p class=code id=tag>&lt;extension
    id=<p class=code id=cstring>&quot;com.example&quot;</p><p class=code id=tag>
    name=<p class=code id=cstring>&quot;Sample Rendering Extension&quot;</p><p class=code id=tag>
    point=<p class=code id=cstring>&quot;org.eclipse.debug.ui.memoryRenderingTypes&quot;</p><p class=code id=tag>&gt;</p>
    <p class=code id=tag>&lt;renderingBinding
        renderingIds=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;enablement&gt;</p>
            <p class=code id=tag>&lt;instanceof value=<p class=code id=cstring>&quot;com.example.SampleMemoryBlock&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;/enablement&gt;</p>    
    <p class=code id=tag>&lt;/renderingBinding&gt;</p>  
    <p class=code id=tag>&lt;defaultRenderings
        renderingIds=<p class=code id=cstring>&quot;com.example.sampleRendering&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;enablement&gt;</p>
            <p class=code id=tag>&lt;instanceof value=<p class=code id=cstring>&quot;com.example.SampleMemoryBlock&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;/enablement&gt;</p>    
    <p class=code id=tag>&lt;/defaultRenderings&gt;</p>
<p class=code id=tag>&lt;/extension&gt;</p>  
</pre>
</p>   

In the above example, the Sample Rendering is defined as a valid rendering for SampleMemoryBlock. Whenever SampleMemoryBlock is created in the Memory View, a Sample Rendering will be created.
<p></p>

<h6 class=CaptionFigColumn id=header>API Information: </h6><p>
<li>Value of the attribute <b>renderingFactory </b> must be a fully qualifed name of a Java class that implements <b>IMemoryRenderingFactory</b>.</li>
<li>Value of the attribute <b> value </b> from the <b>viewTabFactory</b> rendering property must be a fully qualifed name of a Java class that implements <b>IMemoryViewTabFactory</b>.</li>
<li>Value of the attribute <b>instanceof</b> from the <b> enablement </b> element must be a fully qualified name of a Java class that implements the interface <b>IMemoryBlock</b>.</li>
</p>
<p></p>

<h6 class=CaptionFigColumn id=header>Supplied Implementation: </h6>The debug platform provides the following rendering types:<br>
<li>Hex Rendering (rendering id: org.eclipse.debug.ui.rendering.raw_memory)</li>
<li>ASCII Rendering (rendering id: org.eclipse.debug.ui.rendering.ascii)</li>
<li>Signed Integer Rendering (rendering id: org.eclipse.debug.ui.rendering.signedint)</li>
<li>Unsigned Integer Rendering (rendering id: org.eclipse.debug.ui.rendering.unsignedint) </li>
<br>
The debug platform provides a memory view to host renderings.
<p></p>

<br>
<p class=note id=copyright>
Copyright (c) 2004 IBM Corporation and others.<br>
All rights reserved. This program and the accompanying materials are made 
available under the terms of the Common Public License v1.0 which 
accompanies this distribution, and is available at 
<a href="http://www.eclipse.org/legal/cpl-v10.html">http://www.eclipse.org/legal/cpl-v10.html</a>
<p></p>

</p>
</BODY>
</HTML>
