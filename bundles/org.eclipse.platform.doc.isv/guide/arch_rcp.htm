<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Rich Client Platform</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Rich Client Platform</H2>
<P>
While the Eclipse platform is designed to serve as an open tools platform, it is architected so that its components could be 
used to build just about any client application.  The minimal set of plug-ins needed to build a rich client application is collectively
known as the <b>Rich Client Platform</b>.  
</P>
<p>
Applications that don't require a common resource model can be built using a subset of the platform.  These rich applications
are still based on a dynamic plug-in model, and the UI is built using the same toolkits and extension points.  The layout and
function of the workbench is under fine-grained control of the plug-in developer in this case.
</P>
<p>
The following subsystems are used when building such an application.  They provide the most basic functionality required
to build an application with a user interface.</P>
<H3>Runtime core</H3>
<P >
The platform runtime core implements the runtime engine that starts the platform base and dynamically discovers and runs plug-ins. A
<b> plug-in</b> is a structured component that describes itself to the system using
a manifest
(<b>plugin.xml</b>) file. The platform maintains a registry of installed plug-ins and the function they provide.</P>
<P >
Function is added to the system using a common extension model. <b> Extension points</b> are well-defined function points
in the system that can be extended by plug-ins. When a plug-in contributes an implementation for an extension point, we say that it adds an
<b> extension</b> to the platform. Plug-ins can define their own extension points, so that other plug-ins can integrate tightly with them.</P>
<P >
The extension mechanisms are the only means of adding function to the platform and other plug-ins.
All plug-ins use the same mechanisms.&nbsp; Plug-ins provided with the Eclipse
SDK do not use any private mechanisms in their implementation.</P>
<P >
Extensions are typically written in Java using the platform APIs. However, some extension points accommodate extensions provided as platform executables, ActiveX components, or developed in scripting languages. In general, only a subset of the full platform function is available to non-Java extensions. </P>
<P >
A general goal of the runtime is that the end user should not pay a memory or performance penalty for plug-ins that are installed, but not used. A plug-in can be installed and added to the registry, but the plug-in will not be activated unless
a function provided by the plug-in has been requested according to the user's activity.</P>
<P>The platform runtime is implemented using the OSGi services model. While implementation details of the runtime may not be 
important to many application developers, those already familiar with OSGi will recognize that an Eclipse plug-in is, in effect,
an OSGi bundle.</P>
<P >
The best way to get a feel for the runtime system is to build a plug-in. See
<a HREF="firstplugin.htm" CLASS="XRef"> Plug it in: Hello World meets the workbench</a> to get started
building a plug-in.  Once you have mastered the basics of plug-in writing and you're ready
to define your own extension points, see <a HREF="arch_extension_points.htm">Defining an extension point</a>.
To understand the nuts and bolts of the runtime system, see <a HREF="runtime.htm">Runtime overview</a>.</P>

<H3>
Workbench UI</H3>
<P >
The workbench UI plug-in defines a number of extension points that allow plug-ins to describe the basic content for an
application workbench UI, and for contributing menu and toolbar actions, drag and drop operations, dialogs, wizards, and custom views and editors.</P>
<P >
<a HREF="workbench.htm" CLASS="XRef">Plugging into the workbench</a> introduces the workbench
UI extension points and API by contributing function to the platform IDE workbench.  This overview lets you focus on the different
mechanisms available for adding function to a pre-existing workbench.</P>
<P >
<a HREF="rcp_hello.htm" CLASS="XRef">Revisiting hello world</a> describes the specifics for defining a customized
workbench rather than using the IDE workbench.</P>

<P >
Additional UI plug-ins define frameworks that are generally useful for user
interface development.&nbsp; These frameworks were used to develop the workbench
itself.&nbsp; Using the frameworks not only eases the development of a plug-in's
user interface, but ensures that plug-ins have a common look and feel and a consistent level of workbench integration.</P>


<P >
The Standard Widget Toolkit (SWT) is a low-level, operating system independent toolkit that supports platform integration and portable API.
It is described in
<a HREF="swt.htm" CLASS="XRef">Standard Widget Toolkit</a>.</P>
<P >
The JFace UI framework provides higher-level application constructs for supporting dialogs, wizards, actions, user preferences, and widget management.&nbsp;
The functionality in JFace is described in
<a HREF="dialogs.htm" CLASS="XRef"> Dialogs and wizards</a>, <a HREF="preferences.htm" CLASS="XRef">Preferences and properties</a>, and
<a HREF="jface.htm" CLASS="XRef">JFace: UI framework for plug-ins</a>.</P>

<p><img border="0" src="../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></p>



</BODY>
</HTML>
