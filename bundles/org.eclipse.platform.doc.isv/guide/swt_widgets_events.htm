<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2005. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page." >

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Events</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H3>Events</H3>
<P>Once we create a display and some widgets, and start up the application's
message loop, where does the real work happen? It happens every time an event is
read from the queue and dispatched to a widget. Most of the application logic is
implemented as responses to user events.</P>

<P>The basic pattern is that you add a listener to some widget that you have
created, and when the appropriate event occurs the listener code will be
executed. This simple example is adapted from
<strong>org.eclipse.swt.examples.helloworld.HelloWorld3</strong>:</P>

<pre>
   Display display = new Display ();
   Shell shell = new Shell (display);
   Label label = new Label (shell, SWT.CENTER);
   ...
   shell.addControlListener (new ControlAdapter () {
      public void controlResized (ControlEvent e) {
         label.setBounds (shell.getClientArea ());
      }
   });
</pre>

<P>For each type of listener, there is an interface that defines the listener
(<em>Xyz</em><strong>Listener</strong>), a class that provides event information
(<em>Xyz</em><strong>Event</strong>), and an API method to add the listener
(<strong>add</strong><em>Xyz</em><strong>Listener</strong>).  If there is more
than one method defined in the listener interface then an adapter
(<em>Xyz</em><strong>Adapter</strong>) that implements the listener interface
and provides empty methods is provided as well. All of the events, listeners,
and adapters are defined in the package
<strong><a href="../reference/api/org/eclipse/swt/events/package-summary.html">org.eclipse.swt.events</a></strong>.</P>

<P>The following table summarizes the events that are available and the widgets
that support each event.</P>

<TABLE BORDER="1" width="600">
<colgroup>
    <col width="34%">
    <col width="66%">
</colgroup>
<TR>
<TH><P CLASS="CellHeading">Event Type</P></TH>
<TH><P CLASS="CellHeading">Description</P></TH>
</TR>

<tr>
<td><strong>Activate</strong>, <strong>Decativate</strong></td>
<td>Generated when a Control is activated or deactivated.</td>
</tr>

<TR>
<td><strong>Arm</strong></td>
<td>Generated when a Widget, such as a MenuItem, is armed.</td>
</TR>

<TR>
<td><strong>Close</strong></td>
<td>Generated when a Shell is closed.</td>
</TR>

<TR>
<td><strong>DefaultSelection</strong>, <strong>Selection</strong></td>
<td>Generated when the user selects an item in the control, or when the default
selection occurs.</td>
</TR>

<TR>
<td><strong>Dispose</strong></td>
<td>Generated when a widget is disposed, either programmatically or by the
user.</td>
</TR>

<tr>
<td><strong>DragDetect</strong></td>
<td>Generated when a drag-and-drop user action occurred.</td>
</tr>

<TR>
<td><strong>Expand</strong>, <strong>Collapse</strong></td>
<td>Generated when an item in a Tree is expanded or collapsed.</td>
</TR>

<TR>
<td><strong>FocusIn</strong>, <strong>FocusOut</strong></td>
<td>Generated when a control gains or loses focus.</td>
</TR>

<TR>
<td><strong>Help</strong></td>
<td>Generated when the user requests help for a widget, such as pressing the
F1 key.</td>
</TR>

<TR>
<td><strong>Iconify</strong>, <strong>Deiconify</strong></td>
<td>Generated when a Shell is iconified or deiconified.</td>
</TR>

<TR>
<td><strong>KeyDown</strong>, <strong>KeyUp</strong></td>
<td>Generated when the user presses or releases a keyboard key when the control
has keyboard focus.</td>
</TR>

<TR>
<td><strong>Menu</strong></td>
<td>Generated when a menu is hidden or shown.</td>
</TR>

<tr>
<td><strong>MenuDetect</strong></td>
<td>Generated when the user requested a context menu.</td>
</tr>

<TR>
<td><strong>Modify</strong></td>
<td>Generated when a widget's text is modified.</td>
</TR>

<TR>
<td><strong>MouseDown</strong>, <strong>MouseUp</strong>,
<strong>MouseDoubleClick</strong>, <strong>MouseWheel</strong></td>
<td>Generated when the user presses, releases, double clicks, or uses the wheel
of the mouse over the control.</td>
</TR>

<TR>
<td><strong>MouseMove</strong></td>
<td>Generated as the user moves the mouse across the control.</td>
</TR>

<TR>
<td><strong>MouseEnter</strong>, <strong>MouseExit</strong>,
<strong>MouseHover</strong></td>
<td>Generated when the mouse enters, exits, or hovers over the control.</td>
</TR>

<TR>
<td><strong>MouseWheel</strong></td>
<td>Generated when the mouse wheel is rotated.</td>
</TR>

<TR>
<td><strong>Move</strong></td>
<td>Generated when a control changes position.</td>
</TR>

<TR>
<td><strong>Paint</strong></td>
<td>Generated when the control needs to be repainted.</td>
</TR>

<TR>
<td><strong>Resize</strong></td>
<td>Generated when a control changes size.</td>
</TR>

<tr>
<td><strong>SetData</strong></td>
<td>Generated when data needs to be set on an item when using VIRTUAL.</td>
</tr>

<tr>
<td><strong>Show</strong>, <strong>Hide</strong></td>
<td>Generated when a control is made visible or hidden.</td>
</tr>

<TR>
<td><strong>Traverse</strong></td>
<td>Generated when a control is traversed by the user using keystrokes.</td>
</TR>

<TR>
<td><strong>Tree</strong></td>
<td>Generated when the user expands or collapses items in the tree.</td>
</TR>

<TR>
<td><strong>Verify</strong></td>
<td>Generated when a widget's text is about to be modified. Gives the
application a chance to alter the text or prevent the modification.</td>
</TR>
</TABLE>


<H4>Untyped events</H4>
<P>The typed event system described above is implemented with a low level,
untyped widget event mechanism. This mechanism is not intended to be used by
applications, but you will see it used inside of the SWT implementation. It
is also used in many of the workbench wizard page implementations.</P>

<P>The untyped mechanism relies on a constant to identify the event type and
defines a generic listener that is supplied with this constant. This allows
the listener to implement a &quot;case style&quot; listener. In the following
snippet, we define a generic event handler and add several listeners to a shell.</P>

<pre>
   Shell shell = new Shell ();
   Listener listener = new Listener () {
      public void handleEvent (Event e) {
         switch (e.type) {
            case SWT.Resize:
               System.out.println (&quot;Resize received&quot;);
               break;
            case SWT.Paint:
               System.out.println (&quot;Paint received&quot;);
               break;
            default:
               System.out.println (&quot;Unknown event received&quot;);
         }
      }
   };
   shell.addListener (SWT.Resize, listener);
   shell.addListener (SWT.Paint, listener);
</pre>

</BODY>
</HTML>