<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="isvGuide.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
Preferences
</TITLE>

<link rel="stylesheet" type="text/css" href="isvGuide.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Preferences</H2>
<P >
The workbench implements a generic preferences architecture that allows plug-ins to store user preference values and contribute a preference page to the workbench preferences dialog. We will look again at the readme tool example to see how this is done, and then look at some of the underlying support for building preference pages.</P>

<H3>org.eclipse.ui.preferencePages</H3>
<P >
The <b><a href="../reference/extension-points/org_eclipse_ui_preferencePages.html"> org.eclipse.ui.preferencePages</a></b> extension point allows you to contribute pages to the workbench preferences
(<b>Window-&gt;Preferences</b>) dialog. The preferences dialog presents a hierarchical list of user preference entries. Each entry displays a corresponding preference page when selected.</P>
<P >
The readme tool uses this extension point to add the Readme Example preferences page.</P>
<P class="Code" >
  &lt;extension<br>
&nbsp;&nbsp;&nbsp; point = &quot;org.eclipse.ui.preferencePages&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;page&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id="org.eclipse.ui.examples.readmetool.Page1"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class=&quot;org.eclipse.ui.examples.readmetool.ReadmePreferencePage&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name="Readme Example"><br>
&nbsp;&nbsp;&nbsp; &lt;/page><br>
   &lt;/extension></P>
<P >
This markup defines a preference page named &quot;Readme Example&quot; which is implemented by the class
<b>ReadmePreferencePage</b>. The class must implement the
<b><a href="../reference/api/org/eclipse/ui/IWorkbenchPreferencePage.html"> IWorkbenchPreferencePage</a></b> interface.</P>
<P > The workbench uses a
<b><a href="../reference/api/org/eclipse/jface/preference/PreferenceManager.html"> PreferenceManager</a></b> to keep a list of all nodes in the preference tree and their corresponding pages. This list can be initialized from information in the plug-in registry without running any plug-in code.&nbsp;
Your plug-in's contribution to the preferences dialog (the &quot;Readme
Example&quot; entry on the left) is shown before any of your code is run. </P>
<P >
<img border="0" src="images/preferences.jpg" width="599" height="531"></P>
<P >
The &quot;Readme Example&quot; preference is added to the top level of the
preference tree on the left.&nbsp; Why? Because a preference page contribution will be added as a root of the tree unless a
<b> category</b> attribute is specified. (The name <b> category</b> is somewhat misleading.
Perhaps a better name is
<b>path</b>.) The <b> category</b> attribute
specifies the id (or a sequence of ids from the root) of the parent page. For example, the following markup would create a second readme tool preference page, &quot;Readme Example Child Page,&quot; as a child of the original page.</P>
<P class="Code" >
  &lt;extension<br>
&nbsp;&nbsp;&nbsp; point = &quot;org.eclipse.ui.preferencePages&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;       &lt;page&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id="org.eclipse.ui.examples.readmetool.Page1"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class=&quot;org.eclipse.ui.examples.readmetool.ReadmePreferencePage&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            name="Readme Example"><br>
&nbsp;&nbsp;&nbsp;       &lt;/page>&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp; &lt;page&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
id=&quot;org.eclipse.ui.examples.readmetool.Page2&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
class=&quot;org.eclipse.ui.examples.readmetool.ReadmePreferencePage2&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            name="Readme Example Child
Page&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
category=&quot;org.eclipse.ui.examples.readmetool.Page1&gt;<br>
&nbsp;&nbsp;&nbsp;       &lt;/page><br>
   &lt;/extension></P>


<P >
Once the user selects the entry for a preference page in the tree on the left,
the workbench will create and display a preference page using the <b> class</b> specified in the
extension definition.&nbsp; This action is what activates the plug-in (if it
wasn't already activated due to another user operation).</P>


<H3>
Preference Page</H3>

<H4>
Defining the page</H4>
<P >
Implementing a preference page is similar to creating a page for a wizard. The preference page supplies a
<b> createContents</b> method that creates the SWT controls representing the page content and adds listeners for any events of interest. The page is responsible for creating and returning the composite that will parent all of the controls in the page.&nbsp;
The following snippet shows the highlights:</P>
<p class="Code">protected Control createContents(Composite parent)<br>
{<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; //composite_textField &lt;&lt; parent<br>
&nbsp;&nbsp;&nbsp; Composite composite_textField = createComposite(parent, 2);<br>
&nbsp;&nbsp;&nbsp; Label label_textField = createLabel(composite_textField, "Text Field");&nbsp;<br>
&nbsp;&nbsp;&nbsp; textField = createTextField(composite_textField);<br>
&nbsp;&nbsp;&nbsp; pushButton_textField = createPushButton(composite_textField, "Change");<br>
<br>
&nbsp;&nbsp;&nbsp; //composite_tab &lt;&lt; parent<br>
&nbsp;&nbsp;&nbsp; Composite composite_tab = createComposite(parent, 2);<br>
&nbsp;&nbsp;&nbsp; Label label1 = createLabel(composite_tab, "Radio Button Options");<br>
<br>
&nbsp;&nbsp;&nbsp; tabForward(composite_tab);<br>
&nbsp;&nbsp;&nbsp; //radio button composite &lt;&lt; tab composite<br>
&nbsp;&nbsp;&nbsp; Composite composite_radioButton = createComposite(composite_tab, 1);<br>
&nbsp;&nbsp;&nbsp; radioButton1 = createRadioButton(composite_radioButton, "Radio button 1");<br>
&nbsp;&nbsp;&nbsp; radioButton2 = createRadioButton(composite_radioButton, "Radio button 2");<br>
&nbsp;&nbsp;&nbsp; radioButton3 = createRadioButton(composite_radioButton, "Radio button 3");<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; initializeValues();<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; return new Composite(parent, SWT.NULL);<br>
}</p>
<P >
 Most of the code in this method is concerned with creating and laying out the controls, so we won't dissect it here.&nbsp;
Here is what the corresponding page looks like:</P>
<P >
<img border="0" src="images/readmepreferences.jpg" width="599" height="531"></P>
<P >
The other primary responsibility of a preference page is to react to the <b> performOk</b> message. Typically, this method
updates and stores the user preferences and, if necessary, updates any other plug-in objects to reflect the change in preferences.</P>
<P >
Preference pages should override the <b> doGetPreferenceStore()</b> method to return a preference store for storing their values. </P>


<H4>
Plug-in preference store</H4>
<P >
Preference stores are similar in nature to dialog settings. In <a HREF="dialogs_settings.htm" CLASS="XRef">Dialog settings</a>, we saw how the
<b><a href="../reference/api/org/eclipse/ui/plugin/AbstractUIPlugin.html"> AbstractUIPlugin</a></b> class maintains dialog settings during the lifetime of a plug-in. The same strategy is employed for user preferences. Your plug-in can add entries to a preference store and update the values as the user changes the settings in your preferences page. The platform will take care of saving these values in your plug-in's
working directory and initializing the preference store from the saved settings.</P>
<P >
The following code in the <b> ReadmePreferencePage</b> obtains the preference store for the
<b>ReadmePlugin</b>.</P>
<P CLASS="Code">
protected IPreferenceStore doGetPreferenceStore() {</P>
<P CLASS="Code">
&nbsp;return ReadmePlugin.getDefault().getPreferenceStore();</P>
<P CLASS="Code">
}</P>
<P >
Because <b> ReadmePlugin</b> extends the <b><a href="../reference/api/org/eclipse/ui/plugin/AbstractUIPlugin.html"> AbstractUIPlugin</a></b> class, it automatically inherits a preference store. This preference store is initialized from a preferences file stored in the
plug-in's directory.&nbsp; The only thing the <b> ReadmePlugin</b> has to do is implement a method that initializes the preferences to their default values. These values are used the first time the preference page is shown or when the user presses the
<b>Defaults</b> button in the preferences page.</P>
<P CLASS="Code">
protected void initializeDefaultPreferences(IPreferenceStore store) {</P>
<P CLASS="Code">
&nbsp;// These settings will show up when Preference dialog</P>
<P CLASS="Code">
&nbsp;// opens up for the first time.</P>
<P CLASS="Code">
&nbsp;store.setDefault(IReadmeConstants.PRE_CHECK1, true);</P>
<P CLASS="Code">
&nbsp;store.setDefault(IReadmeConstants.PRE_CHECK2, true);</P>
<P CLASS="Code">
&nbsp;store.setDefault(IReadmeConstants.PRE_CHECK3, false);</P>
<P CLASS="Code">
&nbsp;store.setDefault(IReadmeConstants.PRE_RADIO_CHOICE, 2);</P>
<P CLASS="Code">
&nbsp;store.setDefault(IReadmeConstants.PRE_TEXT, &quot;Default text&quot;);</P>
<P CLASS="Code">
}</P>


<P class="Note">
Note:&nbsp; If there are no preferences saved for a plug-in, the plug-in will get an empty preference
store.</P>


<H4>
Retrieving and saving preferences</H4>
<P >
Once you've associated your plug-in's preference store with your preference page, you can implement the logic for retrieving and saving the preferences.</P>
<P >
Preference pages are responsible for initializing the values of their controls using the preferences settings from the preference store. This
process is similar to initializing dialog control values from dialog settings. The
<b> ReadmePreferencePage</b> initializes all of its controls in a single method,
<b>initializeValues</b>, which is called from its <b> createContents</b> method.</P>
<P CLASS="Code">
private void initializeValues() {</P>
<P CLASS="Code">
&nbsp;IPreferenceStore store = getPreferenceStore();</P>
<P CLASS="Code">
&nbsp;checkBox1.setSelection(store.getBoolean(IReadmeConstants.PRE_CHECK1));</P>
<P CLASS="Code">
&nbsp;checkBox2.setSelection(store.getBoolean(IReadmeConstants.PRE_CHECK2));</P>
<P CLASS="Code">
&nbsp;checkBox3.setSelection(store.getBoolean(IReadmeConstants.PRE_CHECK3));<BR>
&nbsp;...</P>
<P >
When the <b>OK</b> (or <b>Apply</b>) button is pressed, the current values of the controls on the preference page should be stored back into the
preference store. The
<b> ReadmePreferencePage</b> implements this logic in a separate method,
<b>storeValues</b>.</P>
<P CLASS="Code">
private void storeValues() {</P>
<P CLASS="Code">
&nbsp;IPreferenceStore store = getPreferenceStore();</P>
<P CLASS="Code">
&nbsp;store.setValue(IReadmeConstants.PRE_CHECK1, checkBox1.getSelection());</P>
<P CLASS="Code">
&nbsp;store.setValue(IReadmeConstants.PRE_CHECK2, checkBox2.getSelection());</P>
<P CLASS="Code">
&nbsp;store.setValue(IReadmeConstants.PRE_CHECK3, checkBox3.getSelection());</P>
<P CLASS="Code">
&nbsp;...</P>
<P CLASS="Code">
}</P>
<P >
When the user presses the <b>Defaults</b> button, the platform will restore all preference store values to the default values specified in the plug-in class. However, your preference page is responsible for reflecting these default values
in the controls on the preference page. The
<b> ReadmePreferencePage</b> implements this in <b>initializeDefaults</b>.</P>
<P CLASS="Code">
private void initializeDefaults() {</P>
<P CLASS="Code">
&nbsp;IPreferenceStore store = getPreferenceStore();</P>
<P CLASS="Code">
&nbsp;checkBox1.setSelection(store.getDefaultBoolean(IReadmeConstants.PRE_CHECK1));</P>
<P CLASS="Code">
&nbsp;checkBox2.setSelection(store.getDefaultBoolean(IReadmeConstants.PRE_CHECK2));</P>
<P CLASS="Code">
&nbsp;checkBox3.setSelection(store.getDefaultBoolean(IReadmeConstants.PRE_CHECK3));</P>
<P CLASS="Code">
&nbsp;...</P>
<P CLASS="Code">
}</P>



<H3>
Field editors</H3>
<P >
The implementation of a preference page is primarily SWT code.&nbsp; SWT code is
used to create the preference page controls, set the values of the controls, and
retrieve the values of the controls. The
<b><a href="../reference/api/org/eclipse/jface/preference/package-summary.html">org.eclipse.jface.preference</a></b> package provides helper classes, called
<b> field editors</b>, that create the widgets and implement the value setting and retrieval code for the most common preference types. The platform provides field editors for displaying and updating many value types, including booleans, colors, strings, integers, fonts, and file names.</P>
<P >
 <b><a href="../reference/api/org/eclipse/jface/preference/FieldEditorPreferencePage.html"> FieldEditorPreferencePage</a></b> implements a
page that uses these field editors to display and store the preference values on the page.</P>
<P >
Instead of creating SWT controls to fill its contents, a <b><a href="../reference/api/org/eclipse/jface/preference/FieldEditorPreferencePage.html"> FieldEditorPreferencePage</a></b> creates field editors to display the contents.</P>
<P CLASS="Code">
public void createFieldEditors() {</P>
<P CLASS="Code">
&nbsp;&nbsp;&nbsp; // The first string is the preference key name<BR>
&nbsp;&nbsp;&nbsp; // The second string is the label shown next to the widget&nbsp;<br>
&nbsp;&nbsp;&nbsp; addField(new BooleanFieldEditor(USE_OLD_MODE, &quot;Use old mode&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getFieldEditorParent()));</P>
<P CLASS="Code">
&nbsp;&nbsp;&nbsp; addField(new StringFieldEditor(APPLICATION_NAME, &quot;Application Name&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getFieldEditorParent()));</P>
<P CLASS="Code">
&nbsp;&nbsp;&nbsp; addField(new ColorFieldEditor(COLOR, &quot;Text Color&quot;,
getFieldEditorParent()));<br>
&nbsp;&nbsp;&nbsp; ...</P>
<P >
Each field editor is assigned the name of its corresponding preference key and the text label for the SWT
control that it will create. The kind of control created depends on the type of field editor. For example, a boolean field editor creates a checkbox.</P>
<P >
Since the preference page is associated with a preference store (specified in the
<b> doGetPreferenceStore</b> method), the code for storing the current values,
for initializing the control values from the preference store, and for restoring the controls to
their default values can all be implemented in the
<b><a href="../reference/api/org/eclipse/jface/preference/FieldEditorPreferencePage.html">FieldEditorPreferencePage</a></b>.</P>
<P >
The <b><a href="../reference/api/org/eclipse/jface/preference/FieldEditorPreferencePage.html"> FieldEditorPreferencePage</a></b> 
will use a grid layout with one column as the default layout for field editor
widgets.&nbsp; For special layout requirements, you can override the <b>createContents</b> method.</P>

<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" width="195" height="12"></a></p>

</BODY>
</HTML>
