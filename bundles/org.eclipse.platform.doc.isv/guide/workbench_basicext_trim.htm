<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2006. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page." >

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<script language="JavaScript" src="PLUGINS_ROOT/org.eclipse.help/livehelp.js"></script>
<TITLE>org.eclipse.ui.menus</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H3>
org.eclipse.ui.menus</H3>

<p>
<b>Disclaimer:</b> The <code>org.eclipse.ui.menus</code> extension point in eclipse 3.2 is only partially implemented. It currently does not support menu or toolbar definitions or extensions (the existing contributon extensions should be used for these). It is, however, the only mechanism through which 'trim' widgets can be contributed into the workbench. This section will demonstrate how to use it for this purpose.
</p>
<p>
A 'trim' widget is a control that gets sited into a location (called a 'Trim Area') on the outer boundary of the Workbench Window. The
most common example is the generic 'status line' which almost all GUI's place along the bottom of the window.
The extension point <b><a href="../reference/extension-points/org_eclipse_ui_menus.html">org.eclipse.ui.menus</a></b>
allows plug-ins to add views to the workbench. Plug-ins that contribute trim must register the trim in their
<b> plugin.xml </b> file and provide&nbsp; configuration information about the trim, such as its implementation class, the trim group (trim bar) that it resides in and layout information sucha s whether the trim wishes to use available 'extra' space during 
its layout within the trim area.
</p>
<p>
The interface for contributed trim is defined in <b><a href="../reference/api/org/eclipse/ui/IWorkbenchWidget.html">IWorkbenchWidget</a></b>, but plug-ins
can (are in fact encouraged) to choose to extend the
<b><a href="../reference/api/org/eclipse/ui/part/AbstractWorkbenchTrimWidget.html"> AbstractWorkbenchTrimWidget</a></b> class rather than implement the interface from scratch.
</p>
<p>
For the readmetool example we've contributed a fairly naive trim widget that simply displays a string and an indication of which side the trim is currently docked on.
</p>
<p>
<img src="images/readmetrim.png" alt="" border="0">
</p>
<p>
Let's take a look at the extension point definition used to contribute this piece of trim:
</p>
<img src="images/readmetrimxml.png" alt="" border="0">
<p>
The first section of the extension (the 'group' definition) simply defines the id of the group and defines a 'location' for the group as being at the start of the 'status' group (i.e. at the beginning of the bottom trim area). The second section (the 'widget' definition) specifies the implementation 'class' of the widget and defines the 'location' of the widget as being placed within the previously defined group.
</p>
<p>
Note that in both cases the bar's 'type' is defined as <b>trim</b> (which is the only type currently supported).
</p>
<p>
Once you have the actual <code>readmetool</code> example installed, take a look at the implementation of the <code>ReadmeTrimWidget's fill</code> method. This is different from the other <code>fill</code> methods used when adding widgets into toolbars or menus in that, because trim can be dragged from one area to another, it also passes the 'side' that the trim is being placed into, allowing the implementor to tailor the widget's display based on its location by changing orientation etc. The current implementation simply changes the displayed text to reflect the current location. Also note how the 'dispose'/'fill' life-cycle is handled; there will be repeated calls to <code>dispose</code> and <code>fill</code> generated by workbench changes (i.e. changing perspectives or dragging the trim to a new side).
</p>
<p>
One thing that is not reflected in this sample's code is the reliance of the trim layout manager on the trim's proper implementation of the widget control's <code>computeSize</code> method. The widget must be capable of calculating and returning its 'preferred' size since this is used throughout the layout management implementation to determine, for example, how much space is needed for a particular trim area. See the SWT documentation for notes on how to correctly implement '<code>computeSize</code> correctly.
</p>
</BODY>
</HTML>
