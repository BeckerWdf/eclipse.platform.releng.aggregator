<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../../../../../org.eclipse.platform.doc.user/book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<title>Component Framework</title>

</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="Head"> Component Framework</H1>
<P CLASS="Para"> By providing simple API for views and editors, also known as 
  parts, the Component Framework permits existing parts to be nested and composed. 
  The Component Framework API allows clients to instantiate parts inside arbitrary 
  SWT composites, improves robustness and leak proofing by having a part communicate 
  with local interfaces on its site rather than reaching to global objects, allows 
  clients to extend the set of interfaces available from a site and provides a 
  framework for clients to create their own reusable components using the same 
  API available to views and editors. The Component Framework also allows for 
  constructing and destructing a part with atomic operations and allows existing 
  parts to use new site interfaces.</P>
<P CLASS="Para"><img alt="Image of NameViewNew view"
 src="../../../../../images/NameViewNew.PNG"><br>
</P>
<P CLASS="Para">This simple example provides a view that sets its name, title, 
  tooltip, and image and demonstrates how to write an editor or view using the 
  component framework. It shows the source using the component API. New parts 
  can take arguments in their constructor and do not need to implement any particular 
  interface or need to inherit from any particular base class.<br>
  <br>
</P>
<div style="margin-left: 40px;"><code>/**<br>
  &nbsp;* Sample view that sets its name, tooltip, image, and content description. 
  The view<br>
  &nbsp;* uses a custom image supplied by its plug-in.<br>
  &nbsp;* <br>
  &nbsp;* @since 3.1<br>
  &nbsp;*/<br>
  public class NameViewNew {<br>
  &nbsp;&nbsp;&nbsp; /**<br>
  &nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; */<br>
  &nbsp;&nbsp;&nbsp; public NameViewNew(Composite parent, INameable name, IPluginImages 
  images) {<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name.setName("Name View (New)");<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name.setContentDescription("content description");<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name.setTooltip("This is a tooltip");<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; name.setImage(images.getImage("icons/sample.gif"));<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Create some bogus view contents<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Label content = new Label(parent, SWT.NONE);<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; content.setText("View contents go here");<br>
  &nbsp;&nbsp;&nbsp; }<br>
  }</code><br>
</div>
<p>Notice that the arguments given to the view's constructor are already aware 
  of their context. For example, the IPluginImages interface does not need to 
  be told which plug-in the view belongs to. Similarly, the interfaces are resistant 
  to leaks. In this example, the view's image is allocated and deallocated automatically 
  by the INameable implementation, so the view itself doesn't need to implement 
  a dispose method.<br>
  <br>
  It is interesting to note that the API for views and editors is exactly the 
  same. In other words, if we had chosen to register the NameViewNew class with 
  the org.eclipse.ui.editors extension point, it could also be used as an editor 
  without further modification.<br>
</p>
<h2> Site interfaces</h2>
The arguments in a part's constructor are known as dependencies. Part dependencies 
replace the various adapters and get methods, for example, to access a site's 
IActionBars, a component-based part would take an IActionBars instance in its 
constructor. <br>
<br>
New-style sites offer an open-ended set of interfaces. Any plug-in can extend 
the set of site interfaces using the <span
 style="font-style: italic;">org.eclipse.core.component.types</span> extension 
point. Although the set of site interfaces can be extended, all sites support 
the same set, ensuring that any part can be plugged into any site. It is possible 
to view the complete set of site interfaces using the PDE plug-in registry view.<br>
<br>
The workbench supplies the following site interfaces:<br>
<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr> 
      <td style="vertical-align: top; font-weight: bold;">Interface<br> </td>
      <td style="vertical-align: top; font-weight: bold;">Description<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IErrorContext<br> </td>
      <td style="vertical-align: top;">Constructs and logs IStatus messages to 
        the plug-in log.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">Bundle<br> </td>
      <td style="vertical-align: top;">The plug-in bundle containing the part's 
        implementation. This informs other components, such as the implementation 
        of IErrorContext, automatically of their plug-ins.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IContainer<br> </td>
      <td style="vertical-align: top;">The site's container. This object can be 
        queried for any of the other site interfaces, which can be useful if the 
        part wants to redirect or multiplex everything from its site to its children.<br> 
      </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">INameable<br> </td>
      <td style="vertical-align: top;">Allows a part to set its name, icon, tooltip, 
        and content description. Replaces the various get methods and listeners 
        on IWorkbenchPart.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">Composite<br> </td>
      <td style="vertical-align: top;">Parent composite for the part. This composite 
        is not shared with any other parts, and will be disposed at the same time 
        as the part. The part is allowed to set the layout and attach listeners 
        to this composite.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">ISecondaryId<br> </td>
      <td style="vertical-align: top;">Interface that returns a part's secondary 
        ID when used as a multi-instance view.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">ResourceManager<br> </td>
      <td style="vertical-align: top;">Safely allocates and deallocates Images, 
        Fonts, Colors, and other SWT resources. Ensures that identical resources 
        are shared between parts and that any leaks get cleaned up when the part 
        is closed.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IDirtyHandler<br> </td>
      <td style="vertical-align: top;">Allows parts to set or clear their dirty 
        state.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IMessageDialogs<br> </td>
      <td style="vertical-align: top;">Displays error, warning, and info dialogs 
        to the user.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IActionBars<br> </td>
      <td style="vertical-align: top;"><font color="#FF0000">Serves the same purpose 
        as getViewSite().getActionBars() did with the Eclipse 3.0 API.<br>
        </font> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IMultiplexer<br> </td>
      <td style="vertical-align: top;">Provides a multiplexed component with access 
        to its multiplexer and any shared interfaces<br>
        . </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">ISavedState<br> </td>
      <td style="vertical-align: top;">Holds the previously-persisted state of 
        the part.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IPartFactory<br> </td>
      <td style="vertical-align: top;">Allows a part to create nested views and 
        editors.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IPartDescriptor<br> </td>
      <td style="vertical-align: top;">Holds meta-info about a part such as its 
        ID, title, default image, and so on.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">IEditorInput<br> </td>
      <td style="vertical-align: top;">Holds the editor input for an editor. Points 
        to an empty editor input for views.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">ISelectionHandler<br> </td>
      <td style="vertical-align: top;">Handles selection changes. Parts can use 
        this to change the selection they provide to the workbench.<br> </td>
    </tr>
  </tbody>
</table>
<p>It is up to the part's containing context to determine whether the part gets 
  a unique instance for each interface or an object shared among several parts. 
  The part's constructor never receives a null argument.</p>
<p>&nbsp;</p>
<h3>Using new site interfaces with existing parts</h3>
<p>Although constructor injection is convenient, it would be impractical to rewrite 
  every existing editor and view to use constructor injection in order to take 
  advantage of the new site interfaces. For this reason, all of the new interfaces 
  are also available to existing views as adapters on IWorkbenchPartSite. <br>
</p>
<p>Here is a view containing a single button that opens a message dialog.</p>
<p><img
 src="../../../../../images/dependencies_view.PNG" alt="Image of DependenciesViewOld"></p>
<p> The following example shows the source for a new-style view that opens the 
  dialog using the new IMessageDialogs interface. 
<div style="margin-left: 40px;">
  <p><code>/**<br>
    &nbsp;* Demonstrates how to use component dependencies in a new-style part.<br>
    &nbsp;* <br>
    &nbsp;* @since 3.1<br>
    &nbsp;*/<br>
    public class DependenciesViewNew {<br>
    &nbsp;&nbsp;&nbsp; // Dependencies<br>
    &nbsp;&nbsp;&nbsp; private IMessageDialogs dialogs;<br>
    &nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp; /**<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp; public DependenciesViewNew(Composite parent, <span
 style="color: rgb(255, 0, 0);">IMessageDialogs dialogs</span>) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="color: rgb(255, 0, 0);">this.dialogs = dialogs;</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Button testButton = new Button(parent, 
    SWT.PUSH);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testButton.setText("Open a dialog");<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testButton.addSelectionListener(new 
    SelectionAdapter() {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (non-Javadoc)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void widgetSelected(SelectionEvent 
    e) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; openADialog();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp; private void openADialog() {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="color: rgb(255, 0, 0);">dialogs.open(IStatus.INFO, "This is a message");</span><br>
    &nbsp;&nbsp;&nbsp; }<br>
    }</code><br>
  </p>
  </div>
<p>This example shows a traditional view that opens a dialog using IMessageDialogs 
  demonstartes that this is also possible using a traditional workbench part. 
  The lines in red font show how the IMessageDialogs interface is initialized 
  and used in each case. <br>
  </span>
  </p>
<div style="margin-left: 40px;">
  <p><code>/**<br>
    &nbsp;* Demonstrates how to use component dependencies in an old-style view<br>
    &nbsp;* <br>
    &nbsp;* @since 3.1<br>
    &nbsp;*/<br>
    public class DependenciesViewOld extends ViewPart {<br>
    &nbsp;&nbsp;&nbsp; // Dependencies<br>
    &nbsp;&nbsp;&nbsp; private IMessageDialogs dialogs;<br>
    &nbsp;&nbsp; &nbsp;<br>
    &nbsp;&nbsp;&nbsp; // Main widget<br>
    &nbsp;&nbsp;&nbsp; private Composite parent;<br>
    &nbsp;&nbsp; &nbsp;<br>
    &nbsp;&nbsp;&nbsp; /* (non-Javadoc)<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.ui.IWorkbenchPart#createPartControl(org.eclipse.swt.widgets.Composite)<br>
    &nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp; public void createPartControl(Composite parent) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.parent = parent;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="color: rgb(255, 0, 0);">this.dialogs = (IMessageDialogs)getSite().getAdapter(IMessageDialogs.class);</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Button testButton = new Button(parent, 
    SWT.PUSH);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testButton.setText("Open a dialog");<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testButton.addSelectionListener(new 
    SelectionAdapter() {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (non-Javadoc)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void widgetSelected(SelectionEvent 
    e) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; openADialog();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp; &nbsp;<br>
    &nbsp;&nbsp;&nbsp; private void openADialog() {<br>
    <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    if (dialogs != null) {</span><br style="color: rgb(255, 0, 0);">
    <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    dialogs.open(IStatus.INFO, "This is a message");</span><br
 style="color: rgb(255, 0, 0);">
    <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    }</span><br>
    &nbsp;&nbsp;&nbsp; }<br>
    <br>
    &nbsp;&nbsp;&nbsp; /* (non-Javadoc)<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.ui.IWorkbenchPart#setFocus()<br>
    &nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp; public void setFocus() {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setFocus();<br>
    &nbsp;&nbsp;&nbsp; }<br>
    }</code></p>
  <p>&nbsp;</p>
  <h2>Part interfaces</h2>
  <p>Parts do not need to implement any particular interface or inherit from any 
    particular base class. However, parts may optionally implement certain interfaces 
    in order to receive callbacks from their parent. For example, if a part implements 
    the IFocusable interface then its parent will use that interface to give focus 
    to the part. Parts are allowed to either implement the interface directly 
    or implement IAdaptable and provide an adapter for the interface.<br>
    <br>
    Similarly to site interfaces, part interfaces are registered in the <span
 style="font-style: italic;">org.eclipse.core.component.types </span>extension 
    point. There is a slight difference in the XML markup to distinguish between 
    a site interface and a part interface. Any plugin can extend the set of interfaces 
    available for a view to implement, and the PDE plugin registry can be used 
    to find all such interfaces.<br>
    <br>
    The workbench provides the following interfaces to be implemented by parts: 
  </p>
  <table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
    <tbody>
      <tr> 
        <td style="vertical-align: top; font-weight: bold;">Interface<br> </td>
        <td style="vertical-align: top; font-weight: bold;">Description<br> </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">IFocusable<br> </td>
        <td style="vertical-align: top;">Allows the part to implement setFocus.<br> 
        </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">IPersistable<br> </td>
        <td style="vertical-align: top;">Allows the part to save its state between 
          sessions.<br> </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">IMultiPart<br> </td>
        <td style="vertical-align: top;">Indicates that the part has the notion 
          of an active child.<br> </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">ISite<br> </td>
        <td style="vertical-align: top;">Although this is never actually implemented 
          by a part, the implementations of other part interfaces can depend on 
          ISite in order to gain access to their site.<br> </td>
      </tr>
    </tbody>
  </table>
  <br>
  Parts may also implement lifecycle interfaces. Lifecycle interfaces are different 
  from regular part interfaces in several ways: 
  <ul>
    <li>A lifecycle interface must be implemented directly (it cannot be provided 
      as an adapter);</li>
    <li>Any or all of a part's dependencies may also implement the lifecycle interface;</li>
    <li>When a lifecycle notification is sent to a part, it is also sent to all 
      of the part's dependencies;</li>
    <li>Lifecycle interfaces are hardcoded, and are not registered with an extension 
      point.<br>
    </li>
  </ul>
  Parts support the following lifecycle interfaces:<br>
  <table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
    <tbody>
      <tr> 
        <td style="vertical-align: top; font-weight: bold;">Interface<br> </td>
        <td style="vertical-align: top; font-weight: bold;">Description<br> </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">IDisposable<br> </td>
        <td style="vertical-align: top;">Receives a notification when the component 
          is disposed.<br> </td>
      </tr>
      <tr> 
        <td style="vertical-align: top;">INestedComponent<br> </td>
        <td style="vertical-align: top;">Implemented by children of a multiplexer. 
          Receives activate and deactivate messages when the active part changes.<br> 
        </td>
      </tr>
    </tbody>
  </table>
  <br>
  <br>
  <h1> Instantiating parts</h1>
  All interaction with a part happens through an ISite. From the point of view 
  of someone creating a part, the ISite <span
 style="font-style: italic;">is</span> the part. An ISite can either be created 
  from an IPartFactory or by directly instantiating the Site class.<br>
  <br>
  To destroy a part, dispose the control for its ISite.<br>
  <h2>Instantiating parts using IPartFactory </h2>
  <p>Views and editors are normally created using an IPartFactory and IPartFactory 
    can only create parts registered with the views or editors extension point. 
    . Parts created by IPartFactory depend on an IWorkbenchPage and cannot outlive 
    the IWorkbenchPage. IPartFactory creates parts by ID and the part's implementation 
    class does not need to be API. An IPartFactory can be obtained from IWorkbenchPage. 
    Parts can also take an IPartFactory in their constructor to create nested 
    children. </p>
  <p>This example demonstrates how to create a view using IPartFactory.<br>
  </p>
  <div style="margin-left: 40px;"><code>/**<br>
    &nbsp;* Used to create instances of editors and views.<br>
    &nbsp;* <br>
    &nbsp;* @since 3.1<br>
    &nbsp;*/<br>
    public interface IPartFactory {<br>
    &nbsp;&nbsp;&nbsp; /**<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * Creates an instance of a view. Returns an &lt;code&gt;ISite&lt;/code&gt; 
    for the newly created view.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * When the caller is done with the part it should 
    dispose the part's main control. This can<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * be accomplished by calling &lt;code&gt;ISite.getControl().dispose()&lt;/code&gt;, 
    or by disposing the <br>
    &nbsp;&nbsp;&nbsp;&nbsp; * parent composite.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param viewId ID of the view, as registered with 
    the org.eclipse.ui.views extension point<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param parentComposite parent composite for the 
    view. If the view is successfully created, it<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will 
    create exactly one new child control in this composite. <br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param context local context for the view. This 
    object can override any or all of the view's dependencies.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the 
    view has a dependency that isn't found in the local context, a default implementation 
    will<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be supplied 
    by the org.eclipse.core.component.types extension point.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param savedState previously saved state of the 
    part, or null if none<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @return an ISite for the newly created view<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @throws CoreException if unable to create the part<br>
    &nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp; public ISite createView(String viewId, Composite parentComposite, 
    IContainerContext context, IMemento savedState) throws CoreException;<br>
    &nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp; /**<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * Creates an instance of an editor. Returns an &lt;code&gt;ISite&lt;/code&gt; 
    for the newly created editor.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * When the caller is done with the part it should 
    dispose the part's main control. This can<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * be accomplished by calling &lt;code&gt;ISite.getControl().dispose()&lt;/code&gt;, 
    or by disposing the <br>
    &nbsp;&nbsp;&nbsp;&nbsp; * parent composite.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * <br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param editorId ID of the editor, as registered 
    with the org.eclipse.ui.editors extension point<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param parentComposite parent composite for the 
    editor. If the editor is successfully created,<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it will 
    create exactly one new child control in this composite.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param context local context for the editor. This 
    object can override any or all of the part's dependencies.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the 
    part has a dependency that isn't found in the local context, a default implementation 
    will<br>
    &nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be supplied 
    by the org.eclipse.core.component.types extension point.<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param input IEditorInput for this editor<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @param savedState previously saved state for the 
    part, or null if none<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @return an ISite for the newly created editor<br>
    &nbsp;&nbsp;&nbsp;&nbsp; * @throws CoreException if unable to create the part<br>
    &nbsp;&nbsp;&nbsp;&nbsp; */<br>
    &nbsp;&nbsp;&nbsp; public ISite createEditor(String editorId, Composite parentComposite, 
    IContainerContext context, IEditorInput input, IMemento savedState) throws 
    CoreException;<br>
    }</code><span style="font-weight: bold;"></span><br>
    <span style="font-weight: bold;"></span></div>
  <br>
  <p>Here is an example of an action that creates 
  a view using IPartFactory</p>
  <div style="margin-left: 40px;"><code>/**<br>
    &nbsp;* Demonstrate how to open a view by its ID from an IWorkbenchPage.<br>
    &nbsp;*/<br>
    public class CreateViewByIdAction implements IWorkbenchWindowActionDelegate 
    {<br>
    &nbsp;&nbsp;&nbsp; private IWorkbenchWindow window;<br>
    <br>
    &nbsp;&nbsp;&nbsp; public void run(IAction action) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IWorkbenchPage page = window.getActivePage();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (page == null) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>// 
    ...uninteresting error-handling code removed...</code><code><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final Shell tempShell = new Shell(window.getShell(), 
    SWT.DIALOG_TRIM | SWT.RESIZE);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.setLayout(new FillLayout());<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.setText("Problems");<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    IPartFactory factory = page.getPartFactory();</span><br
 style="color: rgb(255, 0, 0);">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>
    <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    factory.createView(IPageLayout.ID_PROBLEM_VIEW, tempShell, new ContainerContext(), 
    null);</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (CoreException e) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>// 
    ...uninteresting error-handling code removed...</code><code><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Open the dialog<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.open();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display d = tempShell.getDisplay();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!tempShell.isDisposed()) 
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!d.readAndDispatch())<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    d.sleep();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    &nbsp;&nbsp;&nbsp; }<br>
    <br>
    &nbsp;&nbsp;&nbsp; public void init(IWorkbenchWindow window) {<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.window = window;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    <br>
    &nbsp;&nbsp;&nbsp; // ...remaining (empty) methods removed...<br>
    }<br>
    <br>
    </code>
    <h2>Instantiating parts using the Site class</h2>
    Not all parts are views or editors. Clients can also use the part API to create 
    their own reusable components. Such parts are not registered with the view 
    or editor extension points, but can make use of most of the API available 
    to views and editors. Although there is nothing stopping clients from inventing 
    their own API for reusable components, making use of the part pattern allows 
    their components to be embedded inside anything that supports embedding of 
    views or editors.<br>
    <br>
    Parts created using the Site class have the following properties: 
    <ul>
      <li>The part's implementation class must be known and loaded; </li>
      <li>The part does not need to be a view or editor, and does not require 
        any extension markup; </li>
      <li>The part has access to a reduced set of site interfaces, so views and 
        editors cannot be created in this manner unless their JavaDoc explicitly 
        says so;</li>
      <li>These parts can be created without a workbench page;</li>
      <li>This pattern can only be used to create component-based parts. Views 
        and editors that implement IViewPart or IEditorPart cannot be created 
        in this manner.</li>
    </ul>
    The Site constructor must be given the part's implementation class and the 
    associated plugin bundle. The plugin bundle determines where log error messages 
    will be logged and where the part should search when looking for resources 
    in its own plugin.<br>
    <br>
    The following example demonstrates how to use the Site class to instantiate 
    a part directly. In this example, we instantiate the NameTestView part in 
    a dialog. Although NameTestView is called a view and can make use of the view 
    API, it doesn't actually need to be registered with the org.eclipse.ui.views 
    extension point unless the workbench is actually supposed to use it as a view.<br>
    <br>
    <code><br>
    </code> 
    <div style="margin-left: 40px;"><code>/**</code><br>
      <code>&nbsp;* Demonstrate how to open a part programmatically using the 
      Site class.</code><code></code><code></code><br>
      <code>&nbsp;*/</code><br>
      <code>public class ProgrammaticViewCreationExampleAction implements IWorkbenchWindowActionDelegate 
      {</code><br>
      <code>&nbsp;&nbsp;&nbsp; private IWorkbenchWindow window;</code><code></code><code></code><br>
      <code></code><br>
      <code>&nbsp;&nbsp;&nbsp; public void run(IAction action) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a shell</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final Shell tempShell = 
      new Shell(window.getShell(), SWT.DIALOG_TRIM | SWT.RESIZE);</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.setLayout(new 
      FillLayout());</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.setText("Name 
      test view");</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bundle thisPlugin = ComponentExamplesPlugin.getDefault().getBundle(); 
      </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      // Instantiate the NameTestView part (this line is the whole point of the 
      example)</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      // It demonstrates how the Site class can be used instead of calling NameTestView's 
      constructor.</code><br>
      <code></code><code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      Site testPart = new Site(tempShell, new ContainerContext(), </code><br
 style="color: rgb(255, 0, 0);">
      <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      thisPlugin, </code><br style="color: rgb(255, 0, 0);">
      <code><span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      NameTestView.class);&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (CoreException 
      e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...uninteresting 
      error-handling code removed...<br>
      </code><code></code><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      }</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Open a modal dialog</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempShell.open();</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display d = tempShell.getDisplay();</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!tempShell.isDisposed()) 
      {</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      if (!d.readAndDispatch())</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      d.sleep();</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
      <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
      <code>&nbsp;&nbsp;&nbsp; }</code><code></code><br>
      <code></code><br>
      <code>&nbsp;&nbsp;&nbsp; public void init(IWorkbenchWindow window) {</code><br>
      <code>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.window = window;</code><br>
      <code>&nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; </code><code>// ...remaining (empty) methods removed...</code><br>
      <code>}</code></div>
    <code> </code></div>
    </div>
<h2> Passing arguments to a part<br>
</h2>
A parent passes arguments to its children using a ContainerContext. The context 
can pass arguments to the constructor of a part or specify a factory for constructing 
those arguments. For example, a particular ContainerContext might specify rules 
like:<br>
<ul>
  <li>If the child asks for an INameable, use object X; </li>
  <li>If the child asks for an IActionBars, construct one using factory Y;</li>
  <li>If the child asks for any unknown type and object Z can be adapted to that 
    type, return the adapter; </li>
  <li>If the child asks for a dependency that can't be satisfied in any other 
    way, redirect to some other context.</li>
</ul>
If the context doesn't supply a particular dependency, the child will use the 
default implementation from the <span
 style="font-style: italic;">org.eclipse.core.component.types</span> extension 
point. Since the context can override any of the arguments a part gets in its 
constructor, the parent can override any of the interfaces the part normally obtains 
from its site. For example, the parent could force its child to use a different 
implementation of IActionBars by supplying an IActionBars in the context.<br>
<ul>
  <p>The parent has several options for constructing the context:</p>
  <li>Provide the child with a specific instance for one of its dependencies;</li>
  <li>Provide the child with a factory to construct one of its dependencies, if 
    needed; </li>
  <li>Redirect some or all of its own dependencies to one of its children; </li>
  <li>Use a multiplexer to dynamically redirect one or more dependencies to its 
    active child; </li>
  <li>Let the child use the default implementation for some or all of its dependencies. 
  </li>
</ul>
The following <span style="font-weight: bold;">DefaultContextView</span>, <span style="font-weight: bold;">RedirectContextView</span> 
and <span style="font-weight: bold;">OverrideInstanceView</span> examples demonstrate 
each possibility. 
<h3> Default context</h3>
The following example shows the source for a view that creates two nested children 
in the default context. The fact that the children are created in the default 
context means that the parent doesn't care about the child's name, toolbar, selection, 
and so on and isn't prepared to deal with them. If the parent wanted to do something 
with, say, the current selection in one of its children, it would have needed 
to pass an ISelectionHandler to that child. The end result is shown below the 
example.<br>
<br>
<span style="font-weight: bold;"> </span> 
<div style="margin-left: 40px;"><code>/**</code><br>
  <code>&nbsp;* View that demonstrates how to create two nested children </code><br>
  <code>&nbsp;* with the default context.</code><code></code><code></code><code></code><br>
  <code>&nbsp;*/</code><br>
  <code>public class DefaultContextView {</code><br>
  <code>&nbsp;&nbsp;&nbsp; public DefaultContextView(Composite parent, IPartFactory 
  factory) throws CoreException {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a resource navigator</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext1 
  = new ContainerContext();&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view1 = factory.createView(</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IPageLayout.ID_RES_NAV, parent, viewContext1, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create property view</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext2 
  = new ContainerContext();</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view2 = factory.createView(IPageLayout.ID_PROP_SHEET, 
  parent, viewContext2, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setLayout(new FillLayout());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>}</code><span style="font-weight: bold;"></span><br>
  <span style="font-weight: bold;"></span></div>
<span style="font-weight: bold;"> <br>
</span> 
<div style="margin-left: 40px;"><img
 src="file:///D:/workspaces/head_workspace/platform-ui-home/components-proposal/images/DefaultContextView.PNG"
 alt="Screenshot of DefaultContextView"><br>
</div>
<br>
<h3>Redirecting dependencies from a parent to a child<br>
</h3>
<span style="font-weight: bold;"></span>This example demonstrates how to redirect 
a site interface from the parent to a child. This composite view contains a resource 
navigator and a property view. It redirects its selection handler to the resource 
navigator and it redirects its action bars to the properties view. The result 
is a view that provides a resource selection and contains the toolbar and menu 
from the properties view, as shown below. <br>
<span style="font-weight: bold;"><br>
</span> 
<div style="margin-left: 40px;"><code>public class RedirectContextView {</code><br>
  <code>&nbsp;&nbsp;&nbsp; /**</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp; public RedirectContextView(Composite parent, IPartFactory 
  factory, ISelectionHandler selection, IActionBars actionBars) throws CoreException 
  {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a resource navigator. 
  Redirect the navigator's selection directly to our parent.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext1 
  = new ContainerContext()</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addInstance(ISelectionHandler.class, 
  selection); </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view1 = factory.createView(</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IPageLayout.ID_RES_NAV, </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  parent, viewContext1, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create property view. Allow 
  the property view to use our action bars directly.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext2 
  = new ContainerContext()</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addInstance(IActionBars.class, 
  actionBars);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view2 = factory.createView(IPageLayout.ID_PROP_SHEET, 
  parent, viewContext2, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setLayout(new FillLayout());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>}</code><span style="font-weight: bold;"></span><br>
  <span style="font-weight: bold;"></span></div>
<br>
<br>
<div style="margin-left: 40px;"><img
 src="file:///D:/workspaces/head_workspace/platform-ui-home/components-proposal/images/RedirectContextView.PNG"
 alt="Screenshot of RedirectContextView"><br>
</div>
<h3>Providing dependencies directly<br>
</h3>
This example demonstrates how to supply a child with one of its dependencies directly. 
In this example, we create a composite view containing a problems view and a properties 
view. We supply the problem view with an ISelectionHandler in order to display 
the number of selected problems in the content description. The end result is 
shown below.<br>
<br>
<span style="font-weight: bold;"> </span> 
<div style="margin-left: 40px;"><code>public class OverrideInstanceView {<br>
  &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp; /**<br>
  &nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; */<br>
  &nbsp;&nbsp;&nbsp; public OverrideInstanceView(Composite parent, IPartFactory 
  factory, final INameable name) throws CoreException {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext1 = new 
  ContainerContext();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add an ISelectionHandler to the 
  view's context. Whenever the view changes its selection,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // display the number of selected 
  items in the content description<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; viewContext1.addInstance(ISelectionHandler.class, 
  new ISelectionHandler() {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (non-Javadoc)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @see 
  org.eclipse.ui.part.services.ISelectionHandler#setSelection(org.eclipse.jface.viewers.ISelection)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void 
  setSelection(ISelection newSelection) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  if (newSelection instanceof IStructuredSelection) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IStructuredSelection sel = (IStructuredSelection)newSelection;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  int selectionSize = sel.size();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  name.setContentDescription(MessageFormat.format("{0} problems selected", <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  new String[] {Integer.toString(selectionSize)}));<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a problem view<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view1 = factory.createView(<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IPageLayout.ID_PROBLEM_VIEW, parent, viewContext1, null);<br>
  &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create property view<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContainerContext viewContext2 = new 
  ContainerContext();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISite view2 = factory.createView(IPageLayout.ID_PROP_SHEET, 
  parent, viewContext2, null);<br>
  &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setLayout(new FillLayout());<br>
  &nbsp;&nbsp;&nbsp; }<br>
  }</code><span style="font-weight: bold;"></span><br>
  <span style="font-weight: bold;"></span></div>
<br>
<span style="font-weight: bold;"> <br>
</span> 
<div style="margin-left: 40px;"><img
 src="file:///D:/workspaces/head_workspace/platform-ui-home/components-proposal/images/OverrideInstanceView.PNG"
 alt="Screenshot of OverrideInstanceView"><br>
  <br>
</div>
<h3> Multiplexing an interface</h3>
<p>Many composite parts will have the notion of an active child. Such parts may 
  want to dynamically attach a dependency to the child that is currently active. 
  <br>
  <br>
  For example, we may want to create a view that arranges its children in a tab 
  folder. The parent may want to set its own name and icon to match that of its 
  active child. We could accomplish this using the following pattern: </p>
<ul>
  <li> Remember the current name and icon for each child part;</li>
  <li> Set the initial name and icon to its default value (read from IPartDescriptor);</li>
  <li> Attach an INameable to each child that listens to name and icon changes;</li>
  <li> Whenever the name or icon of the active part changes, change the name and 
    icon of the outer part to match;</li>
  <li> Whenever the active child changes, change the name and icon of the outer 
    part to the saved name and icon for the child.</li>
</ul>
We will refer to this as multiplexing the INameable interface.<br>
<br>
In general, the multiplexer pattern works like this: 
<ul>
  <li> Remember some state for each child, with an appropriate initial value;</li>
  <li> Keep track of state changes in all children;</li>
  <li> When the state of the active child changes, forward the change to a shared 
    interface;</li>
  <li> When a new child becomes active, forward its entire state to the shared 
    interface.</li>
</ul>
Since this pattern is quite common, we supply a Multiplexer class to support it. 
Clients that supply new types of interfaces using the <span
 style="font-style: italic;">org.eclipse.core.component.types </span>extension 
point can also supply a multiplexed version of their interface. The multiplexed 
version will: 
<ul>
  <li>Implement the interface;</li>
  <li> Know what state to remember for each child and what the initial value should 
    be;</li>
  <li> Receive notifications when it is activated/deactivated;</li>
  <li> Forward its state to a shared instance when it is active. </li>
</ul>
Clients using the Multiplexer don't need to know the details of multiplexing each 
interface. They can simply attach an INameable to the multiplexer as though it 
was a part, and attach the multiplexer to each child part as though it were an 
INameable. This is shown in the following example, use of the multiplexer has 
been highlighted in red. Multiplexers need to be explicitly disposed.<br>
<code><br>
</code> 
<div style="margin-left: 40px;"><code>public class MultiplexNameView implements 
  IDisposable {</code><br>
  <code>&nbsp;&nbsp;&nbsp; private Multiplexer mplex;</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; private ISite view1;</code><br>
  <code>&nbsp;&nbsp;&nbsp; private ISite view2;</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; private Listener focusListener = new Listener() {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (non-Javadoc)</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.swt.widgets.Listener#handleEvent(org.eclipse.swt.widgets.Event)</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void handleEvent(Event 
  e) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
  (e.widget == view1.getControl()) {</code><br>
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  mplex.setActivePart(view1);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else 
  if (e.widget == view2.getControl()) {</code><br>
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  mplex.setActivePart(view2);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; };</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; /**</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp; public MultiplexNameView(Composite parent, IPartFactory 
  factory, INameable name) throws CoreException {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a multiplexer. Redirect 
  our INameable to the multiplexer</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="color: rgb(255, 0, 0);">mplex = new Multiplexer(new ContainerContext().addInstance(INameable.class, 
  name));</span></code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a resource navigator. 
  Give the navigator a multiplexed INameable, but use</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults for all of the 
  other interfaces.</code><br>
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ContainerContext viewContext1 = new ContainerContext()</code><br
 style="color: rgb(255, 0, 0);">
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  .delegateTo(INameable.class, mplex); </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view1 = factory.createView(</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IPageLayout.ID_RES_NAV, parent, viewContext1, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view1.getControl().addListener(SWT.Activate, 
  focusListener);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create property view. Give 
  the properties view a multiplexed INameable, but use</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // defaults for everything 
  else.</code><br>
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ContainerContext viewContext2 = new ContainerContext()</code><br
 style="color: rgb(255, 0, 0);">
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  .delegateTo(INameable.class, mplex);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view2 = factory.createView(IPageLayout.ID_PROP_SHEET, 
  parent, viewContext2, null);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view2.getControl().addListener(SWT.Activate, 
  focusListener);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make the navigator active 
  initially</code><br>
  <code style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  mplex.setActivePart(view1);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setLayout(new FillLayout());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  </code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; /* (non-Javadoc)</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; * @see org.eclipse.core.component.IDisposable#dispose()</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp; public void dispose() {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mplex.dispose();</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>}</code><br>
</div>
<h2>How sites work</h2>
<p>The following example shows the internal structure of a Site. Sites procure 
  some context from their owner as well as expose a set of adapters. The site 
  combines the context from its parent with the default dependencies from the 
  <span style="font-style: italic;">org.eclipse.core.components.types </span>extension 
  point to compute the dependencies for its part. If it needs to create any dependencies 
  from a factory, it remembers those objects so that it can send them lifecycle 
  notifications later. <br>
  <br>
  The adapters that a site returns to its owner are created in a similar manner. 
  If the part implements an adapter, the site returns it directly. Otherwise, 
  it looks for a default adapter from the <span
 style="font-style: italic;">org.eclipse.core.components.types </span>extension 
  point. <br>
  <br>
  To avoid any confusion, this should be said explicitly: the adapters that a 
  site returns to its owner are not the same as the adapters it returns to an 
  old-style part. The adapters that an old-style part gets from its site are dependencies, 
  whereas the adapters that a site returns to its parent are adapters for the 
  part itself.<br>
  <br>
  <span style="font-weight: bold;">Figure 3.4.1: Anatomy of a Site</span><br>
  <img alt="" src="../../../../../images/components_diagram.png"
 style="width: 654px; height: 485px;"></p>
<h2> Nesting</h2>
To the outside world, every part is a black box. The part can use IPartFactory 
to create nested children however it sees fit, but it does not expose those children 
directly to the outside world. The following example demonstrates a view with 
two nested children. The end result is shown below.<br>
<br>
<div style="margin-left: 40px;"><code>/**<br>
  &nbsp;* Example view containing a nested error log on the left and a nested 
  property <br>
  &nbsp;* view on the right.<br>
  &nbsp;* <br>
  &nbsp;* @since 3.1<br>
  &nbsp;*/<br>
  public class TestCompositeView {<br>
  &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp; public TestCompositeView(Composite parent, IPartFactory factory) 
  throws CoreException {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 
  Create PDE error log view</span><br
 style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ContainerContext 
  logViewContext = new ContainerContext();&nbsp;&nbsp;&nbsp; </span><br
 style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ISite 
  logView = factory.createView(</span><br
 style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  "org.eclipse.pde.runtime.LogView", </span><br
 style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  parent, logViewContext, null);</span><br style="color: rgb(255, 0, 0);">
  <br style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 
  Create Property view</span><br
 style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ContainerContext 
  emptyContext = new ContainerContext();</span><br style="color: rgb(255, 0, 0);">
  <span style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ISite 
  propertiesView = factory.createView(IPageLayout.ID_PROP_SHEET, parent, emptyContext, 
  null);</span><br>
  <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Construct layout<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GridLayout layout = new GridLayout();<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; layout.numColumns = 2;<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; parent.setLayout(layout);<br>
  <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Arrange error log view<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GridData data1 = new GridData(GridData.FILL_BOTH);<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; logView.getControl().setLayoutData(data1);<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Arrange properties view<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GridData data2 = new GridData(GridData.FILL_BOTH);<br>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; propertiesView.getControl().setLayoutData(data2);<br>
  <br>
  &nbsp;&nbsp;&nbsp; }<br>
  }</code><br>
  <br>
</div>
<span style="font-weight: bold;"> </span>
<h1>Adding new interfaces</h1>
New types of objects can be passed into a part's constructor by registering them 
with the the <span style="font-style: italic;">org.eclipse.core.component.types</span> 
extension point. At this point, we should introduce the term <span
 style="font-style: italic;">component</span>. A component is any sort of object 
that is created from an extension point by injecting arguments into its constructor. 
New-style parts are one sort of component, but there are other types of components 
as well.<br>
<br>
The following example shows a sample types extension. This example specifies that 
the INameable interface should be available from a part's site.<br>
<br>
<div style="margin-left: 40px;"><code>&lt;extension</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point="org.eclipse.core.component.types"&gt;</code><br>
  <code>&nbsp;&nbsp; &lt;component<br>
  </code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initializer="org.eclipse.ui.part.SiteInitializer"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface="org.eclipse.ui.part.services.INameable"<br>
  </code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implementation="org.eclipse.ui.internal.part.services.NullNameableService"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; singleton="true"</code><br>
  <code>&nbsp;&nbsp; /&gt;</code><br>
  <code></code><code>&lt;/extension&gt;</code><br>
</div>
<p>The <span style="font-style: italic;">initializer</span> attribute indicates 
  where the interface will be used. For example, the string "org.eclipse.ui.part.SiteInitializer" 
  means that the interface is used on a part's site. We could have also used "org.eclipse.ui.part.PartInitializer" 
  if the interface was intended for parts themselves to implement. <br>
  <br>
  The <span style="font-style: italic;">interface</span> attribute is the name 
  of the interface. This must exactly match the type that the component will receive 
  in its constructor. If we create an extension that supplies Strings and a component 
  asks for an Object, it will not use our extension even though it would have 
  been a compatible type. <br>
  <br>
  The <span style="font-style: italic;">implementation</span> attribute identifies 
  the default implementation of the interface. It either points to a component 
  class that implements the interface or a ComponentFactory that can create them, 
  for additional information, see the ComponentFactory section . This implementation 
  is used to satisfy a dependency whenever a component requests this interface 
  and it can't be found in its parent context. All interfaces must supply a default 
  implementation. This means that a correctly written component will always work 
  in a given scope, regardless of how many dependencies are supplied by its parent 
  context. The implementation cannot override or extend the interface attribute 
  by implementing additional interfaces. Other components can depend on this component 
  through its registered interface, but cannot depend on the implementation class 
  directly. <br>
  <br>
  The <span style="font-style: italic;">singleton</span> attribute indicates whether 
  the default implementation is a singleton. If true, then a single instance will 
  be created and shared between every other component that needs it. If false, 
  then a new instance will be created for each container that needs it. For example, 
  in the case of parts, singleton=:"false" would mean that one instance will be 
  created for every part.<br>
</p>
<h2>Initializers<br>
</h2>
The main purpose of an initializer is to identify a scope. However, it is more 
than just a unique identifier. It points to the Java class that supplies initialization 
information to the scope. In order to create an object from the org.eclipse.core.component.types 
extension point, Eclipse must manually construct an initializer of the appropriate 
type. This allows Eclipse to pass required context to components from outside 
the component framework. Any component is allowed to depend on the initializer 
for its scope, it to access this context. Currently most of the initializers provided 
by the workbench have an empty public interface, so most clients would not want 
to do this yet. <br>
<br>
Inheritance <span style="font-style: italic;"><span
 style="font-weight: bold;">is</span> </span>taken into consideration between 
initializer types. Registering a component type on an initializer's base class 
will also affect the initializer and all of its subclasses. Initializers cannot 
be interfaces, so only single inheritance is possible. For example, an interface 
registered on <span
 style="font-style: italic;">org.eclipse.core.component.ExtensionInitializer </span>would 
be visible both from a part and from its site since <span
 style="font-style: italic;">org.eclipse.core.component.ExtensionInitializer</span> 
is a base class for both the part and site initializers.<br>
<br>
The workbench supplies the following initializer types:<br>
<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr> 
      <td style="vertical-align: top; font-weight: bold;">Initializer<br> </td>
      <td style="vertical-align: top; font-weight: bold;">Base class<br> </td>
      <td style="vertical-align: top; font-weight: bold;">Used for<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">org.eclipse.core.component.ExtensionInitializer<br> 
      </td>
      <td style="vertical-align: top;">none<br> </td>
      <td style="vertical-align: top;">Dependencies used by any component created 
        from an extension point.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">org.eclipse.ui.part.PartInitializer<br> 
      </td>
      <td style="vertical-align: top;">org.eclipse.core.component.ExtensionInitializer</td>
      <td style="vertical-align: top;">Interfaces that can be implemented by a 
        part.<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">org.eclipse.ui.part.SiteInitializer</td>
      <td style="vertical-align: top;">org.eclipse.core.component.ExtensionInitializer</td>
      <td style="vertical-align: top;">Components available from a site (such 
        as things a part can take in its constructor).<br> </td>
    </tr>
    <tr> 
      <td style="vertical-align: top;">org.eclipse.ui.part.SiteMultiplexerInitializer<br> 
      </td>
      <td style="vertical-align: top;">org.eclipse.ui.part.SiteInitializer</td>
      <td style="vertical-align: top;">Dependencies that only apply to site inside 
        a multiplexer (used to override the default component implementation provided 
        by a site).<br> </td>
    </tr>
  </tbody>
</table>
<br>
<h2> Component implementation</h2>
Components registered with the types extension point are much like part components. 
They can take a set of dependencies in their constructor and must implement the 
interface they were registered for. This example shows the aforementioned implementation 
of the NullNameableService.<br>
<br>
<div style="margin-left: 40px;"><code>/**</code><br>
  <code>&nbsp;* Default implementation of the Nameable service. All methods are 
  no-ops.</code><br>
  <code>&nbsp;* </code><br>
  <code>&nbsp;* @since 3.1</code><br>
  <code>&nbsp;*/</code><br>
  <code>public class NullNameableService implements INameable {</code><br>
  <code></code><br>
  <code>&nbsp;&nbsp;&nbsp; /**</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp; public NullNameableService() {</code><code></code><code>}</code><code></code><br>
  <code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void setName(String newName) {}</code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void setContentDescription(String contentDescription) 
  {</code><code>}</code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void setImage(ImageDescriptor theImage) {</code><code>}</code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void setTooltip(String toolTip) {</code><code>}</code><br>
  <code>}</code><br>
</div>
<br>
This may be a simple example as the class doesn't do anything, however it demonstrates 
a common pattern. The INameable service is used to tell the parent about some 
state in the child. With this type of interface, the default implementation typically 
doesn't do anything. This makes sense: if the parent doesn't care about the state 
of its child, it can be ignored. By convention, we use the "Null" prefix to indicate 
that this is a component that doesn't do anything. This type of object is usually 
registered as a singleton since it would be wasteful to create multiple instances 
of such a trivial object. Clients should ensure that any new interfaces that report 
state are capable of being multiplexed.<br>
<br>
If the purpose of the interface is to allocate resources or generate output, the 
default implementation will typically do something more useful. The following 
example shows the implementation of the DefaultMessageDialogs class. Since this 
class is intended for generating interactive output, it has a useful default implementation 
and would not support multiplexing. Since this class needs access to a part's 
Composite, it cannot be a singleton. By convention, we use the class prefix "Default" 
to indicate that this is a default component with some useful behavior.<br>
<br>
<span style="font-weight: bold;"> </span> 
<div style="margin-left: 40px;"><code>/**</code><br>
  <code>&nbsp;* Default implementation of the IMessageDialogs interface. Takes 
  the part's </code><br>
  <code>&nbsp;* control as context and allows the part to open dialogs in a child 
  shell.</code><br>
  <code>&nbsp;* </code><br>
  <code>&nbsp;* @since 3.1</code><br>
  <code>&nbsp;*/</code><br>
  <code>public class DefaultMessageDialogs implements IMessageDialogs {</code><br>
  <code></code><br>
  <code>&nbsp;&nbsp;&nbsp; private Composite control;</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; /**</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; * Component constructor. Do not invoke directly.</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp; */</code><br>
  <code>&nbsp;&nbsp;&nbsp; public DefaultMessageDialogs(Composite control) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.control = control;</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void open(IStatus message) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (message.getSeverity() == 
  IStatus.ERROR) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorDialog.openError(control.getShell(), 
  null, null, message);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open(message.getSeverity(), 
  message.getMessage());</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code></code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void openError(String message, Throwable cause) 
  {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open(new Status(IStatus.ERROR, 
  </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  WorkbenchPlugin.getDefault().getBundle().getSymbolicName(),</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  IStatus.OK,</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  message,</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  cause));</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void open(int severity, String message) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (severity == IStatus.ERROR) 
  {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDialog.openError(control.getShell(), 
  null, message);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (severity == IStatus.WARNING) 
  {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDialog.openWarning(control.getShell(), 
  null, message);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageDialog.openInformation(control.getShell(), 
  null, message);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>}</code><span style="font-weight: bold;"></span><br>
  <span style="font-weight: bold;"></span></div>
<p>Here is the associated extension point markup for DefaultMessageDialog.</p>
<div style="margin-left: 40px;"><code>&lt;extension</code><code> point="org.eclipse.core.component.types"&gt;</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;component</code><br>
  <code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  initializer="org.eclipse.ui.part.SiteInitializer"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface="org.eclipse.ui.part.services.IMessageDialogs"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implementation="org.eclipse.ui.internal.part.services.DefaultMessageDialogs"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; singleton="false"</code><code>/&gt;</code><br>
  <code>&lt;/extension&gt;</code><br>
</div>
<h2>Implementing multiplexing components</h2>
In order to be used in a Multiplexer, site interfaces need to register an alternative 
default implementation with the <span
 style="font-style: italic;">org.eclipse.ui.part.SiteMultiplexerInitializer</span> 
scope. Since this extends the site scope, the more specific multiplexer version 
will take priority over the default version when used in a Multiplexer. <br>
<br>
A multiplexed component will almost always use the following pattern: 
<ol>
  <li>Implement the INestedComponent lifecycle interface;</li>
  <li>Take an IMultiplexer in their constructor and use it to access the shared 
    version of their interface; </li>
  <li>Store the part's state;</li>
  <li>Listen to state changes in the child and update the stored state appropriately;</li>
  <li>Each time the component is activated, it should forward the stored state 
    to the shared interface in the multiplexer; </li>
  <li>While the component is active, it should forward state changes directly 
    to the shared interface.</li>
</ol>
The following example demonstrates the code used by the workbench to multiplex 
the ISelectionHandler interface with ChildSelectionHandler. 
<br>
<br>
<div style="margin-left: 40px;"><code>/**</code><br>
  <code>&nbsp;* Multiplexed version of the ISelectionHandler interface</code><br>
  <code>&nbsp;* </code><br>
  <code>&nbsp;* @since 3.1</code><br>
  <code>&nbsp;*/</code><br>
  <code>public class ChildSelectionHandler implements ISelectionHandler, INestedComponent 
  {</code><br>
  <code></code><br>
  <code>&nbsp;&nbsp;&nbsp; private ISelectionHandler parent;</code><br>
  <code>&nbsp;&nbsp;&nbsp; private ISelection selection;</code><br>
  <code>&nbsp;&nbsp;&nbsp; private boolean isActive = false;</code><br>
  <code>&nbsp;&nbsp;&nbsp; private IMultiplexer multiplexer;</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp; public ChildSelectionHandler(IMultiplexer mplex) throws 
  DependencyException {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.multiplexer = mplex;</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get access to the shared 
  ISelectionHandler being multiplexed (we should</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only modify it when we're 
  the active child)</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.parent = (ISelectionHandler)mplex.getSharedComponents().getComponent(ISelectionHandler.class);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the initial state (the 
  part's initial selection will be null</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // until it explicitly sets 
  it).</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code></code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public IMultiplexer getMultiplexer() {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return the multiplexer we 
  were created with</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return multiplexer;</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><code></code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void activate() {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Forward our stored selection 
  to the shared interface</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setSelection(selection);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isActive = true;</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><br>
  <code></code><code>&nbsp;&nbsp;&nbsp; public void deactivate() {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isActive = false;</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; </code><code></code><br>
  <code>&nbsp;&nbsp;&nbsp; public void setSelection(ISelection newSelection) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Remember the child's new 
  selection</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selection = newSelection;</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (isActive) {</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 
  If we're active, forward the selection directly to the shared</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 
  interface</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent.setSelection(newSelection);</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br>
  <code>&nbsp;&nbsp;&nbsp; }</code><code></code><br>
  <code>}</code><br>
</div>
Here is the associated extension point markup for ChildSelectionHandler.<br>
<br>
<span style="font-weight: bold;"> </span> 
<div style="margin-left: 40px;"><code>&lt;extension</code><code> point="org.eclipse.core.component.types"&gt;</code><br>
  <code>&nbsp;&nbsp; &lt;component</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implementation="org.eclipse.ui.internal.part.services.ChildSelectionHandler"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface="org.eclipse.ui.part.services.ISelectionHandler"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; singleton="false"</code><br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initializer="org.eclipse.ui.part.SiteMultiplexerInitializer"/&gt;</code><br>
  <code>&lt;/extension&gt;</code><br>
  <code></code><br>
  <br>
</div>
<div style="margin-left: 40px;"><img src="../../../../../images/composite_view.PNG"
 alt="Screenshot of TestCompositeView"><br>
  <br>
</div>
<p><a href="../../../../../org.eclipse.platform.doc.user/notices.html"><img src="../../../../../org.eclipse.platform.doc.user/cpy.gif" border="0" alt="Legal notices" ></a> 
</p>
</BODY>
</HTML>
