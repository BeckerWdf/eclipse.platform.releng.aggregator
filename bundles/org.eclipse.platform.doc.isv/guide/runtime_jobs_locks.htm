<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Locks</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H3>
Locks</H3>
<p>
It's possible that multiple jobs in the system need to access and manipulate the same object.
<b><a href="../reference/api/org/eclipse/core/runtime/jobs/ILock.html">ILock</a></b> defines protocol
for granting exclusive access to a shared object.  When a job needs access to the shared object, it <i>acquires</i> a lock
for that object.  When it is finished manipulating the object, it <i>releases</i> the lock. 
</p>
<p>
A lock is typically created when the shared object is created or first accessed by a plug-in.  That is, code that
has a reference to the shared object also has a reference to its lock.  We'll start by creating a lock, <b>myLock</b>, that
will be used to control access to <b>myObject</b>:
<font color='#4444CC'><pre>
   ...
   myObject = initializeImportantObject();
   IJobManager jobMan = Platform.getJobManager();
   <b>myLock = jobMan.newLock();</b>
   ...
</pre></font>
A robust implementation of  <b><a href="../reference/api/org/eclipse/core/runtime/jobs/ILock.html">ILock</a></b> 
is provided by the platform.  The job manager provides instances of this lock for use by clients.  These locks
are aware of each other and can avoid circular deadlock.(We'll explain more about that statement in a moment.)
</p>
<p>
Whenever code in a job requires access to <b>myObject</b>, it must first acquire 
the lock on it.  The following snippet shows a common idiom for working with a lock:
<font color='#4444CC'><pre>
...
// I need to manipulate myObject, so I get its lock first.
<b>myLock.acquire();</b>
try {		
	updateState(myObject);  // manipulate the object
} finally {
	<b>lock.release();</b>
}
...
</pre></font>
The <b>acquire()</b> method will not return until the calling job can be granted exclusive access to the lock.  
In other words, if some other job has already acquired the lock, then this code will be blocked until the lock 
is available.  Note that the code that manipulates <b>myObject</b> is wrapped in a <tt>try</tt> block, so that the lock 
can be released if any exceptions occur while working with the object.  
</p>
<p>Seems simple enough, right?  Fortunately, locks are pretty straightforward to use.  They are also reentrant, which
means you don't have to worry about your job acquiring the same lock multiple times.  Each lock keeps a count of the
number of acquires and releases for a particular thread, and will only release from a job when the number of 
releases equals the number of acquires.
</p>
<p>Earlier we noted that locks provided by the job manager are aware of each other and can avoid circular deadlock.  
You can accept this statement at face value or read on if you are curious about the implementation side of locks.
The simplest circular deadlock case occurs when &quot;Job A&quot; acquires &quot;Lock A&quot; and 
subsequently tries to acquire &quot;Lock B.&quot; Meanwhile, &quot;Lock B&quot; is held by &quot;Job B&quot; 
which is now blocked waiting on &quot;Lock A.&quot; The platform avoids these cases by temporarily granting access to
the locks owned by a blocked job to other jobs that are waiting on them if needed to break a deadlock.
</P>

<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></a></p>
</BODY>
</HTML>
