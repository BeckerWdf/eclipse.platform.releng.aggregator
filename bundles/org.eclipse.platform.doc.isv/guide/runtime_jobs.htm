<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Concurrency infrastructure</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Concurrency infrastructure</H2>
<p>
One of the major challenges of a complex system is to remain responsive while tasks are being performed.  This
challenge is even greater in an extensible system, when components that weren't designed to run together are
sharing the same resources.  The
<b><a href="../reference/api/org/eclipse/core/runtime/jobs/package-summary.html"> org.eclipse.core.runtime.jobs</a></b> 
package attempts to address this problem by providing infrastructure for scheduling, executing, and managing 
concurrently running operations.   This infrastructure is based on the use of <b>jobs</b> to represent
a unit of work that can run asynchronously.
<h3>Jobs</h3>
The <b><a href="../reference/api/org/eclipse/core/runtime/jobs/Job.html">Job</a></b> class represents
a unit of asynchronous work running concurrently with other jobs.  To perform a task, a plug-in creates 
a job and then <b>schedules</b> it.  Once a job is scheduled, it is added to a job queue managed by the 
platform.  The platform uses a background scheduling thread to manage all of the pending jobs.  As a running
job completes, it is removed from the queue and the platform decides which job to run next.  When a job 
becomes active, the platform invokes its <b>run()</b> method.  Jobs are best demonstrated with a simple example:
<font color='#4444CC'><pre>
   class TrivialJob extends Job {
      public TrivialJob() {
         super("Trivial Job");
      }
      public IStatus run(IProgressMonitor monitor) {
         System.out.println("This is a job");
         return Status.OK_STATUS;
      }
   }
</pre></font>
The job is created and scheduled in the following snippet:
<font color='#4444CC'><pre>
   TrivialJob job = new TrivialJob();
   System.out.println("About to schedule a job");
   job.schedule();
   System.out.println("Finished scheduling a job");
</pre></font>
The output of this program is timing dependent.  That is, there is no way
to be sure when the job's <b>run</b> method will execute in relation
to the thread that created the job and scheduled it.  The output will
either be:
<font color='#4444CC'><pre>
   About to schedule a job
   This is a job
   Finished scheduling a job
</pre></font>
or:
<font color='#4444CC'><pre>
   About to schedule a job
   Finished scheduling a job
   This is a job
</pre></font>
</p>
<p>
If you want to be certain that a job has completed before continuing, you can use
the <b>join()</b> method.  This method will block the caller until the job has completed, or 
until the calling thread is interrupted.  Let's rewrite our snippet from above in a more 
deterministic manner:
<font color='#4444CC'><pre>
   TrivialJob job = new TrivialJob();
   System.out.println("About to schedule a job");
   job.schedule();
   job.join();
   if (job.getResult().isOk())
      System.out.println("Job completed with success");
   else
      System.out.println("Job did not complete successfully");
</pre></font>
Assuming the <b>join()</b> call is not interrupted, this method is guaranteed to
return the following result:
<font color='#4444CC'><pre>
   About to schedule a job
   This is a job
   Job completed with success
</pre></font>
</p>
<p>
Of course, it is generally not useful to join a job immediately after scheduling it,
since you obtain no concurrency by doing so. In this case you might as well do the work
from the job's run method directly in the calling thread.  We'll look at some examples later on where 
the use of join makes more sense.
</p>
<p>
The last snippet also makes use of the job <b>result</b>.  The result
is the <b><a href="../reference/api/org/eclipse/core/runtime/IStatus.html">IStatus</a></b>
object that is returned from the job's <b>run()</b> method.  You can use this result
to pass any necessary objects back from the job's run method.  The result can also be used to
indicate failure (by returning an <b><a href="../reference/api/org/eclipse/core/runtime/IStatus.html">IStatus</a></b>
with severity <b>IStatus.ERROR</b>), or cancellation (<b>IStatus.CANCEL</b>).
</p>
<h3>Common job operations</h3>
<p>
We've seen how to schedule a job and wait for it complete, but there are many other
interesting things you can to do jobs.  If you
schedule a job but then decide it is no longer needed, the job can be stopped using
the <b>cancel</b> method.  If the job has not yet started running when cancelled,
the job is immediately discarded and will not run.  If, on the other hand, the job 
has already started running, it is up to the job whether it wants to respond to the cancellation.
When you are trying to cancel a job, waiting for it using the <b>join</b> method comes in handy.
Here is a common idiom for cancelling a job, and waiting until the job is finished before
proceeding:
<font color='#4444CC'><pre>
   if (!job.cancel())
      job.join();
</pre></font>
If the cancellation does not take effect immediately, then <b>cancel</b> will return 
false and the caller will use <b>join</b> to wait for the job to successfully cancel.
</p>
<p>
Slightly less drastic than cancellation is the <b>Job.sleep</b> method.  Again,
if the job has not yet started running, this method will cause the
job to be put on hold indefinitely.  The job will still be remembered by the platform,
and a <b>wakeUp</b> call will cause the job to be added to the wait
queue where it will eventually be executed. 
</p>
<h3>Job families</h3>
<p>
It is sometimes useful to work with a group of related jobs.  This can be accomplished using
<b>job families</b>.  A job declares that it belongs to a certain family by overriding the 
<b>belongsTo</b> method:
<font color='#4444CC'><pre>
   public static final String MY_FAMILY = "myJobFamily";
   ...
   class FamilyJob extends Job {
      ...
      public boolean belongsTo(Object family) {
         return family == MY_FAMILY;
      }
   }
</pre></font>
<b><a href="../reference/api/org/eclipse/core/runtime/jobs/IJobManager.html">IJobManager</a></b>
protocol can be used to cancel, join, sleep, or find all jobs in a family:
<font color='#4444CC'><pre>
   IJobManager jobMan = Platform.getJobManager();
   jobMan.cancel(MY_FAMILY);
   jobMan.join(MY_FAMILY, null);
</pre></font>
Since job families are arbitrary objects, you can store interesting
state in the job family itself, and jobs can dynamically decide what families
they belong to as needed. It's important to use family objects that are 
fairly unique, to avoid accidental interaction with the families created by
other plug-ins. 
</p>
<p>
Families are also a convenient way of locating groups of jobs.  The method <b>IJobManager.find(Object family)</b> can
be used to locate instances of all running, waiting, and sleeping jobs at any
given time.
</p>

<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></a></p>
</BODY>
</HTML>