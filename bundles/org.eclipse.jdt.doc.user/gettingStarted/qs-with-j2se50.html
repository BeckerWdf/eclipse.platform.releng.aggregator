<html>
<head><title>Getting Started with Eclipse 3.1 and J2SE 5.0</title></head>
<body>
<h1>Getting Started with Eclipse 3.1 and J2SE 5.0</h1>
<p>
Eclipse 3.1 includes full support for the new features of J2SE 5.0 ("Tiger").
One of the most important consequences of this support is that you 
may not notice it at all--everything you expect to work for J2SE 1.4, 
including refactorings, source actions, quick assist, search, etc., will
work seamlessly with Tiger's new types and syntax.  In this document,
we will introduce some of the more interesting capabilities Eclipse users
will find when working with Tiger.
</p>

<h2>Prerequisites</h2>

<p>
In order to develop code compliant with J2SE 5.0, you will need a J2SE 5.0 Java Runtime Environment (JRE).
If you start Eclipse for the first time using a J2SE 5.0 JRE, then it will use it by default.
Otherwise, you will need to use the <strong>Installed JRE's</strong> dialog 
(<strong>Windows &gt; Preferences &gt; Java &gt; Installed JRE's</strong>) to register it with Eclipse.
</p>

<p>
This document introduces the 
<a href="http://java.sun.com/developer/technicalArticles/releases/j2se15/">new language features</a> 
introduced in J2SE 5.0 very briefly, but it is not a proper tutorial for these features.
</p>

<h3>Compiler Compliance Level</h3>

<p>
To use the new J2SE 5.0 features, you must be working on a project that has a 5.0 compliance level enabled.
New projects can easily be marked as 5.0-compliant on the first page of the <strong>New &gt; Project</strong> wizard.
To convert an existing J2SE 1.4 project to J2SE 5.0, you can simply start using the 5.0 features in your code.
When a compiler error is flagged, use Quick Fix to update the project's compliance level.
</p>

<p>
For more fine-tuned control, 
the compiler compliance level can be set globally for a workspace (<strong>Windows &gt; Preferences &gt; Java &gt; Compiler</strong>)
or individually for each project (From the project's context menu, choose <strong>Properties &gt; Java Compiler</strong>.
Projects with different compliance levels can co-exist in the workspace, and depend on each other.
</p>

<h2>Generic Types</h2>

<p>
Generic types allow objects of the same class to safely operate on objects of different types.
For example, they allow compile-time assurances that a 
<code>List&lt;String&gt;</code> always contains <code>String</code>s, and a <code>List&lt;Integer&gt;</code> always contains <code>Integer</code>s.
</p>

<p>
Anywhere that Eclipse handles a non-generic type, it can handle a generic type:
<ul>
<li> Generic types can be safely renamed.
<li> Type variables can be safely renamed.
<li> Generic methods can be safely extracted from / inlined into generic code.
<li> Code assist can automatically insert appropriate type parameters in parameterized types.
</ul>
</p>

<p>
Eclipse 3.1 provides new options when searching for references to generic types.  Consider this example:

<pre>
import java.util.List;

public class Foo {
	private void foo() {
		List&lt;Integer&gt; l1;
		List&lt;Float&gt; l2;
		List&lt;? extends Number&gt; l3;
		List&lt;String&gt; l4;
	}
}
</pre>

Selecting the reference to <code>List&lt;Integer&gt;</code> and using 
<strong>Search &gt; References &gt; Project</strong> 
will highlight the List types on all four lines.  Using the 
Search View menu, the results can be filtered:

<ul>
<li><strong>Filter Incompatible</strong> leaves only references to types that are assignment-compatible with
the selected type (only <code>List&lt;Integer&gt;</code> and <code>List&lt;? extends Number&gt;</code>) 
<li><strong>Filter Inexact</strong> leaves only type references with the exact same signature 
(only <code>List&lt;Integer&gt;</code>)
</ul>
</p>

<p>    
The user can fine-tune the type warnings produced by the compiler on a per-project level 
(using <strong>Properties &gt; Java Compiler &gt; Errors/Warnings &gt; J2SE options</strong>) or 
method-by-method (by using quick fix to create a <code>@SuppressWarnings("unchecked")</code> annotation)
</p>

<p>
In addition, a new refactoring has been added: <strong>Infer Generic Type Arguments</strong> can infer
type parameters for every type reference in a class, a package, or an entire project, converting code like

<pre>
List l= new ArrayList();
l.add(“Jax”);
</pre>

to 

<pre>
List&lt;String&gt; l= new ArrayList&lt;String&gt;();
l.add(“Jax”);
</pre>
</p>

<h2>Annotations</h2>

<p>
Annotations attach metadata about how Java types and methods are used 
and documented to the Java source and can then affect compilation or 
be queried at run-time.  For example, <code>@Override</code> will trigger
a compiler warning if the annotated method does not override a method in
a superclass:
</p>

<pre>
	@Override public String toString() { return "a"; }
</pre>

<p>
Everything you can do with a Java type, you can do with an annotation:
<ul>
<li> Create new annotations using <strong>New &gt; Annotation</strong>
<li> Refactor: rename, move, change signatures of members, etc.
<li> Search for occurrences
<li> Use code assist to fill in names and values
</ul>
</p>

<h2>Enumerations</h2>

<p>
Enumerations are types that are instantiated at runtime by a known, finite set of objects:

<pre>
public enum Color {
	RED, GREEN, BLUE;
}
</pre>
</p>

<p>
Again, anything you can do to a Java class can be done to an enumeration:

<ul>
<li> Create new enumeratons using <strong>New &gt; Enum</strong>
<li> Refactor: rename, move, rename constants, etc.
<li> Search for occurrences
<li> Use code assist to fill in constants
</ul>
</p>

<h2>Autoboxing</h2>

<p>
Autoboxing and auto unboxing allow for elegant syntax when primitive types are assigned
to or retrieved from Object references:

<pre>
public void foo(Integer i) {
	foo(10);
}
</pre>
</p>

<p>
Eclipse's source manipulation features handle autoboxing seamlessly, 
giving the correct types to new local variables and correct code assists.
For code understanding, it is also possible to flag instances of 
autoboxing or autounboxing as compile warnings 
(<strong>Window &gt; Preferences &gt; Java &gt; Compiler &gt; Errors/Warnings &gt; J2SE Options &gt; Boxing and unboxking conversions</strong>), 
or highlight them using syntax coloring
(<strong>Window &gt; Preferences &gt; Java &gt; Editor &gt; Syntax Coloring &gt; Java &gt; Auto(un)boxed expressions</strong>).
</p>

<h2>Enhanced for loop</h2>

<p>
For the common case of operating on each element of an array or collection in turn, J2SE 5.0 allows a new, cleaner syntax:

<pre>
String[] names= null;
for (String name : names) {
}
</pre>
</p>

<p>
Eclipse 3.1 provides a "foreach" code template that can automatically guess 
the collection to be iterated, and a "Convert to enhanced for loop" quick-assist to
upgrade 1.4-style <code>for</code> loops.
</p>

<h2>Other</h2>

<p>
All other features of J2SE 5.0 are handled flexibly by Eclipse's editing, searching, and code manipulation tools:

<ul>
<li> Static imports
<li> Varargs
<li> Covariant return types
</ul>

Happy coding!
</p>
</body>
</html>