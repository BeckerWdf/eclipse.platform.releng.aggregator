<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Move Participants</title>
<style>@import url("../../book.css");</style>
<style>@import url("../../schema.css");</style>
</HEAD>
<BODY>
<H1><CENTER>Move Participants</CENTER></H1>
<p></p>
<h6 class=CaptionFigColumn id=header>Identifier: </h6>org.eclipse.ltk.core.refactoring.moveParticipants<p></p>
<h6 class=CaptionFigColumn id=header>Since: </h6>3.0
<p></p>

<p>
<h6 class=CaptionFigColumn id=header>Description: </h6>This extension point is used to define refactoring move participants. The reader of the expression provides the following predefined variables which can be referenced via the &lt;with variable="..."&gt; expression element:

<ul>
  <li>Object element: the element to be moved</li>
  <li>List&lt;String&gt; affectedNatures: a list containing the natures of the projects affected 
      by the refactoring</li>
  <li>String processorId: the id of the refactoring processor that will own the participant.
</ul>

The default variable used during expression evaluation is bound to the element variable.<p>
<p>
</p>
<p><h6 class=CaptionFigColumn id=header>Configuration Markup:</h6></p>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.moveParticipant">moveParticipant</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.moveParticipant">moveParticipant</a> (<a href="#e.enablement">enablement</a>)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST moveParticipant</p>
<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>class&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>id</b> - unique identifier for the move participant.</li>
<li><b>name</b> - a human reabable name of the move participant</li>
<li><b>class</b> - the name of the class that provides the participant implementation.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.extension">extension</a> (<a href="#e.moveParticipant">moveParticipant</a>*)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST extension</p>
<p class=code id=dtdAttlist>point&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>point</b> - a fully qualified identifier of the target extension point</li>
<li><b>id</b> - an optional identifier of the extension instance</li>
<li><b>name</b> - an optional name of the extension instance</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.moveParticipant">moveParticipant</a> (<a href="#e.enablement">enablement</a>)&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST moveParticipant</p>
<p class=code id=dtdAttlist>id&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>name&nbsp;&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>class&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>id</b> - unique identifier for the move participant.</li>
<li><b>name</b> - a human reabable name of the move participant</li>
<li><b>class</b> - the name of the class that provides the participant implementation.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.enablement">enablement</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
A generic root element. The element can be used inside an extension point to define its enablement expression.
            The children of an enablement expression are combined using the and operator.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.not">not</a> (<a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a>)&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent a NOT operation on the result of evaluating it's sub-element expression.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.and">and</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an AND operation on the result of evaluating all it's sub-elements expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.or">or</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element represent an  OR operation on the result of evaluating all it's sub-element expressions.</p>
<br><br>
<p class=code id=dtd>&lt;!ELEMENT <a name="e.instanceof">instanceof</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST instanceof</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an instanceof check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object's type is a sub type of the type specified by the attribute value.
            Otherwise EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - a fully qualified name of a class or interface.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.test">test</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST test</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to evaluate the property state of the object in focus. The set of
            testable properties can be extended using the propery tester extension point. The test
            expression returns EvaluationResult.NOT_LOADED if teh property tester doing the actual
            testing isn't loaded yet.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an object's property to test.</li>
<li><b>args</b> - additional arguments passed to the property tester. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
<li><b>value</b> - the expected value of the property. Can be omitted if the property 
                  is a boolean property. The test expression is supposed to return 
EvaluationResult.TRUE if the property matches the value and EvaluationResult.FALSE
otherwise. The value attribute is converted into a Java base type using the following
rules:
<ul>
 <li>the string &quot;true&quot; is converted into Boolean.TRUE</li>
 <li>the string &quot;false&quot; is converted into Boolean.FALSE</li>
 <li>if the string contains a dot then the interpreter tries to convert
 the value into a Float object. If this fails the string is treated as a
 java.lang.String</li>
 <li>if the string only consists of numbers then the interpreter
 converts the value in an Integer object.</li>
 <li>in all other cases the string is treated as a java.lang.String</li>
 <li>the conversion of the string into a Boolean, Float, or Integer can
 be suppressed by surrounding the string with single quotes. For
 example, the attribute value=&quot;'true'&quot; is converted into the
 string &quot;true&quot;</li>
</ul></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST systemTest</p>
<p class=code id=dtdAttlist>property&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>value&nbsp;&nbsp;&nbsp;&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
Tests a system property by calling the System.getProperty method and compares the result
            with the value specified through the value attribute.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>property</b> - the name of an system property to test.</li>
<li><b>value</b> - the expected value of the property. The value is interpreted as a string value.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.equals">equals</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST equals</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to perform an equals check of the object in focus. The expression returns
            EvaluationResult.TRUE if the object is equal to the value provided by the attribute value. Otherwise
            EvaluationResult.FALSE is returned.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - the operatand of the equals tests. The value provided as a string is converted into
                  a Java base type using the same rules as for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST count</p>
<p class=code id=dtdAttlist>value&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to test the number of elements in a collection.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>value</b> - an expression to specify the number of elements in a list. Following wildcard
                  characters can be used:
                  <dl>
                    <dt>*</dt> <dd>any number of elements</dd>
                    <dt>?</dt> <dd>no elements or one element</dd>
                    <dt>+</dt> <dd>one or more elements</dd>
                    <dt>!</dt> <dd>no elements</dd>
                    <dt>integer value</dt> <dd>the list must contain the exact number of elements</dd>
                  </dl></li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.with">with</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST with</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be used for further inspection. It is up to the evaluator
                  of an extension point to provide the variable in the variable pool.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.resolve">resolve</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST resolve</p>
<p class=code id=dtdAttlist>variable&nbsp;CDATA #REQUIRED<p class=code id=dtdAttlist>args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element changes the object to be inspected for all its child element to the object
            referneced by the given variable. If the variable can not be resolved then the expression
            will throw a ExpressionException when evaluating it. The children of a with expression 
            are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>variable</b> - the name of the variable to be resolved. This variable is then used as the object in focus
                  for child element evaluation. It is up to the evaluator of an extension point to provide a 
                  corresponding variable resolver (see IVariableResolver) through the evaluation context passed
                  to the root expression element when evaluating the expression.</li>
<li><b>args</b> - additional arguments passed to the variable resolver. Multiple arguments are seperated
                  by commas. Each individual argument is converted into a Java base type using the same
                  rules as defined for the value attribute of the test expression.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.adapt">adapt</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST adapt</p>
<p class=code id=dtdAttlist>type&nbsp;CDATA #REQUIRED&gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to adapt the object in focus to the type specified by the attribute
            type. The expression returns not loaded if either the adapter or the type referenced isn't
            loaded yet. It throws a ExpressionException during evaluation if the type name doesn't exist 
            at all. The children of an adapt expression are combined using the and operator.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>type</b> - the type to which the object in focus is to be adapted.</li>
</ul>
<br><p class=code id=dtd>&lt;!ELEMENT <a name="e.iterate">iterate</a> (<a href="#e.not">not</a> , <a href="#e.and">and</a> , <a href="#e.or">or</a> , <a href="#e.instanceof">instanceof</a> , <a href="#e.test">test</a> , <a href="#e.systemTest">systemTest</a> , <a href="#e.equals">equals</a> , <a href="#e.count">count</a> , <a href="#e.with">with</a> , <a href="#e.resolve">resolve</a> , <a href="#e.adapt">adapt</a> , <a href="#e.iterate">iterate</a>)*&gt;</p>
<p class=code id=dtd>&lt;!ATTLIST iterate</p>
<p class=code id=dtdAttlist>operator&nbsp;(or|and) &gt;</p>
<p></p>
<p class=ConfigMarkup id=elementDesc>
This element is used to iterate over a variable that is of type java.util.Collection. If
            the object in focus is not of type java.util.Collection then an ExpressionException will
            be thrown while evaluating the expression.</p>
<br>
<ul class=ConfigMarkup id=attlistDesc>
<li><b>operator</b> - either "and" or "or". The operator defines how the child
                  elements will be combined. If not specified, "and" will be used.</li>
</ul>
<br><h6 class=CaptionFigColumn id=header>Examples: </h6>The example below defines a type move participant. The participant is enabled if one of the project affected by the refactoring has a Java nature and when the type to be moved is a JUnit test.

<pre>
<p class=code id=tag>&lt;moveParticipant
    id=<p class=code id=cstring>&quot;org.eclipse.jdt.junit.moveTypeParticipant&quot;</p><p class=code id=tag>
    name=<p class=code id=cstring>&quot;%MoveTypeParticipant.name&quot;</p><p class=code id=tag> 
    class=<p class=code id=cstring>&quot;org.eclipse.jdt.internal.junit.ui.TypeMoveParticipant&quot;</p><p class=code id=tag>&gt;</p>
    <p class=code id=tag>&lt;enablement&gt;</p>
      <p class=code id=tag>&lt;with variable=<p class=code id=cstring>&quot;affectedNatures&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;iterate operator=<p class=code id=cstring>&quot;or&quot;</p><p class=code id=tag>&gt;</p>
          <p class=code id=tag>&lt;equals value=<p class=code id=cstring>&quot;org.eclipse.jdt.core.javanature&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;/iterate&gt;</p>
      <p class=code id=tag>&lt;/with&gt;</p>
      <p class=code id=tag>&lt;with variable=<p class=code id=cstring>&quot;element&quot;</p><p class=code id=tag>&gt;</p>
        <p class=code id=tag>&lt;instanceof value=<p class=code id=cstring>&quot;org.eclipse.jdt.core.IType&quot;</p><p class=code id=tag>/&gt;</p>
        <p class=code id=tag>&lt;test property=<p class=code id=cstring>&quot;org.eclipse.jdt.junit.isTest&quot;</p><p class=code id=tag>/&gt;</p>
      <p class=code id=tag>&lt;/with&gt;</p>
    <p class=code id=tag>&lt;/enablement&gt;</p>
<p class=code id=tag>&lt;/moveParticipant&gt;</p>
</pre>
<p></p>

<h6 class=CaptionFigColumn id=header>API Information: </h6>The contributed class must extend <code>org.eclipse.ltk.core.refactoring.participants.MoveParticipant</code>
<p></p>

<br>
<p class=note id=copyright>
Copyright (c) 2001, 2004 IBM Corporation and others.<br>
All rights reserved. This program and the accompanying materials are made available under the terms of the Common Public License v1.0 which accompanies this distribution, and is available at <a href="http://www.eclipse.org/legal/cpl-v10.html">http://www.eclipse.org/legal/cpl-v10.html</a>
<p></p>

</p>
</BODY>
</HTML>
