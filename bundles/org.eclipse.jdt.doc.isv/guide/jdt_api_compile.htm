<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
     
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
     
  <meta http-equiv="Content-Style-Type" content="text/css">
      
  <link rel="STYLESHEET" href="../book.css" charset="ISO-8859-1" type="text/css">
  <title>Compiling Java code</title>
          
  <link rel="stylesheet" type="text/css" href="../book.css">
</head>
<body>
<h2> Compiling Java code</h2>
<p> The JDT plug-ins include an incremental and batch Java compiler for building 
Java .class files from source code. There is no direct API provided by the 
compiler. It is installed as a builder on Java projects. Compilation is triggered 
using standard platform build mechanisms.</p>
<p> The platform build mechanism is described in detail in <a href="../../org.eclipse.platform.doc.isv/guide/resAdv_builders.htm" class="XRef">
 Incremental project builders</a> .</p>
<h3> Compiling code</h3>
<p> You can programmatically compile the Java source files in a project using 
the build API.</p>
<font color="#4444cc"><pre>
   IProject myProject;
   IProgressMonitor myProgressMonitor;
   myProject.build(IncrementalProjectBuilder.INCREMENTAL_BUILD, myProgressMonitor);
</pre></font>
<p> For a Java project, this invokes the Java incremental project builder
 (along with any other incremental project builders that have been added
to  the project's build spec). The generated .class files are written to
the designated output folder. Additional resource files are also copied to the output folder.&nbsp;</p>
<p> In the case of a full batch build, all the
.class files in the output folder may be 'scrubbed' to ensure that no stale
files are found. This is controlled using a JDT Core Builder Option (<a href="../reference/api/org/eclipse/jdt/core/JavaCore.html#CORE_JAVA_BUILD_CLEAN_OUTPUT_FOLDER">CORE_JAVA_BUILD_CLEAN_OUTPUT_FOLDER</a>).&nbsp;
The default for this option is to clean output folders.&nbsp; Unless this option
is reset, you must ensure that you place all .class files for which
you do not have corresponding source files in a separate class file folder
on the classpath  instead of the output folder.</p>
<p>The
incremental and batch builders can be configured with other options that
control which resources are copied to the output folder.&nbsp; The following sample shows how to set up a resource filter so that files ending with '.ignore' and folders named 'META-INF',
are not copied to the output folder:
<font color="#4444cc">
<pre>   Hashtable options = JavaCore.getOptions();
   options.put(JavaCore.CORE_JAVA_BUILD_RESOURCE_COPY_FILTER, &quot;*.ignore,META-INF/&quot;);
   JavaCore.setOptions(options);
</pre>
</font>
<p> Filenames are filtered if they match one of the supplied patterns. Entire 
folders are filtered if their name matches one of the supplied folder names 
which end in a path separator.</p>
<p> The incremental and batch builders can also be configured to only generate
 a single error when the .classpath file has errors. This option is set by
 default and eliminates numerous errors.&nbsp; See <a href="jdt_api_options.htm##builder">JDT
Core Builder Options</a> for a complete list of builder-related options and
their defaults. </p>
<p>The compiler can also be configured using <a href="../reference/api/org/eclipse/jdt/core/JavaCore.html"><b>JavaCore</b></a>
options.&nbsp; For example, you can define the severity that should be used for
different kinds of problems that are found during compilation.&nbsp; See <a href="jdt_api_options.htm##compiler">JDT
Core Compiler Options </a>for a complete list of compiler-related options and t
heir defaults. </p>
<p>When programmatically configuring options for the builder or compiler, you
should determine the scope of the option.&nbsp; For example, setting up a
resource filter may only apply to a particular project.&nbsp; The following example sets up
the same resource filter shown earlier, but sets it only the individual
project. </p>
<font color="#4444cc">
<pre>   
   Hashtable options = myProject.getOptions(false);  // get only the options set up in this project
   options.put(JavaCore.CORE_JAVA_BUILD_RESOURCE_COPY_FILTER, &quot;*.ignore,META-INF/&quot;);
   myProject.setOptions(options);
</pre>
</font>

<h3>Using the ant javac adapter</h3>
  The Eclipse compiler can be used inside an Ant script using the javac adapter. 
In order to use the Eclipse compiler, you simply need to define the <b>build.compiler</b>
  property in your script. Here is a small example. <font color="#4444cc">
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project name=&quot;compile&quot; default=&quot;main&quot; basedir=&quot;../.&quot;&gt;

	<b>&lt;property name=&quot;build.compiler&quot; value=&quot;org.eclipse.jdt.core.JDTCompilerAdapter&quot;/&gt;</b>

	&lt;property name=&quot;root&quot; value=&quot;${basedir}/src&quot;/&gt;

	&lt;property name=&quot;destdir&quot; value=&quot;d:/temp/bin&quot; /&gt;

	&lt;target name=&quot;main&quot;&gt;
		&lt;javac srcdir=&quot;${root}&quot; destdir=&quot;${destdir}&quot; debug=&quot;on&quot; nowarn=&quot;on&quot; extdirs=&quot;d:/extdirs&quot; source=&quot;1.4&quot;&gt;
		    &lt;classpath&gt;
		      &lt;pathelement location=&quot;${basedir}/../org.eclipse.jdt.core/bin&quot;/&gt;
		    &lt;/classpath&gt;
		&lt;/javac&gt;		
	&lt;/target&gt;
&lt;/project&gt;
</pre>
</font> The syntax used for the javac Ant task can be found in the <a href="http://jakarta.apache.org/ant/manual/CoreTasks/javac.html">
 Ant javac task documentation</a>
 . The current adapter supports the Javac Ant task 1.4.1 and 1.5.3 versions.  
<h3> Problem determination</h3>
<p> JDT Core defines a specialized marker (marker type "<b>org.eclipse.jdt.core.problem</b>
  ") to denote compilation problems. To programmatically discover problems
 detected by the compiler, the standard platform marker protocol should be
 used. See <a href="../../org.eclipse.platform.doc.isv/guide/resAdv_markers.htm" class="XRef">
 Resource Markers</a>
  for an overview of using markers.</p>
<p> The following snippet finds all Java problem markers in a compilation 
unit.</p>
<font color="#4444cc">
<pre>   public IMarker[] findJavaProblemMarkers(ICompilationUnit cu) 
      throws CoreException {
      IResource javaSourceFile = cu.getUnderlyingResource();
      IMarker[] markers = 
         javaSourceFile.findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER,
            true, IResource.DEPTH_INFINITE);
   }
</pre>
</font>
<p> Java problem markers are maintained by the Java project builder and are 
removed automatically as problems are resolved and the Java source is recompiled.</p>
<p>The problem id value is set by one of the constants in <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IProblem.html">
 IProblem</a>
</b>. The problem's id is reliable, but the message is localized and therefore 
can be changed according to the default locale. The constants defined in <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IProblem.html">
 IProblem</a>
</b> are self-descriptive. </p>
<p>An implementation of <b><a href="../reference/api/org/eclipse/jdt/core/IProblemRequestor.html">
 IProblemRequestor</a>
</b> should be defined to collect the problems discovered during a Java operation. 
  Working copies can be reconciled with problem detection if a <b><a href="../reference/api/org/eclipse/jdt/core/IProblemRequestor.html">
 IProblemRequestor</a>
</b> has been supplied for the working copy creation. To achieve this, you 
can use the <b><a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html#reconcile(int, boolean, org.eclipse.jdt.core.WorkingCopyOwner, org.eclipse.core.runtime.IProgressMonitor)">
 reconcile</a></b> method. Here is an example: <font color="#4444cc">
<pre>
  ICompilationUnit unit = ..; // get some compilation unit
			
  // create requestor for accumulating discovered problems
  IProblemRequestor problemRequestor = new IProblemRequestor() {
    public void acceptProblem(IProblem problem) {
      System.out.println(problem.getID() + &quot;: &quot; + problem.getMessage());
    }
    public void beginReporting() {}
    public void endReporting() {}
    public boolean isActive() {	return true; } // will detect problems if active
  };
    
  // use working copy to hold source with error
  ICompilationUnit workingCopy = unit.getWorkingCopy(new WorkingCopyOwner() {}, problemRequestor, null);
  ((IOpenable)workingCopy).getBuffer().setContents(&quot;public class X extends Zork {}&quot;);

  // trigger reconciliation			
  workingCopy.reconcile(NO_AST, true, null, null);
</pre></font> You can add an action on the reported problems in the acceptProblem(IProblem) 
method. In this example, the reported problem will be that <b>Zork cannot 
be resolved or is not a valid superclass</b> and its id is <b>IProblem.SuperclassNotFound</b>
 . <p></p>
<p><a href="../hglegal2003.htm"><img src="../ngibmcpy2003.gif" width=324 height=14 border="0" alt="Copyright IBM Corporation and others 2000, 2003. All Rights Reserved.">
</a>
</p>
</body>
</html>
