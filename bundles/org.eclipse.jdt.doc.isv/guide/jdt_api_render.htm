<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
             	                                    
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
             	                                    
  <meta http-equiv="Content-Style-Type" content="text/css">
              	                                    
  <link rel="STYLESHEET" href="../book.css" charset="ISO-8859-1" type="text/css">
  <title>How to render Java elements in a tree or table viewer</title>
   
</head>
  <body>
<h2>How to present Java elements in a standard JFace viewer</h2>
<p> The JDT-UI API provides several classes to present the Java model or
parts    of it in a standard JFace viewer. This functionality is provided
primarily by: </p>
<ul>
  <li><a href="../reference/api/org/eclipse/jdt/ui/StandardJavaElementContentProvider.html">
            StandardJavaElementContentProvider</a>
             which translates the Java element hierarchy      into a data 
structure    accessible by a tree, table or list viewer</li>
  <li><a href="../reference/api/org/eclipse/jdt/ui/JavaElementLabelProvider.html">
            JavaElementLabelProvider</a>
             which provides corresponding images and labels for a standard
 JFace    viewer</li>
</ul>
            Putting the pieces together is quite simple:<br>
<pre>	<font color="#4444cc">...<br>	IJavaProject jProject= ...;<br><br>	TreeViewer viewer= new TreeViewer(parent); <br>	// Provide members of a compilation unit or class file, but no working copy elements<br>	ITreeContentProvider contentProvider= new StandardJavaElementContentProvider(true, false);<br>	viewer.setContentProvider(contentProvider);<br>	// There are more flags defined in class JavaElementLabelProvider<br>	ILabelProvider labelProvider= new JavaElementLabelProvider(<br>		JavaElementLabelProvider.SHOW_DEFAULT | <br>		JavaElementLabelProvider.SHOW_QUALIFIED | <br>		JavaElementLabelProvider.SHOW_ROOT);<br>	viewer.setLabelProvider(labelProvider);<br>	<br>	// Using the Java model as the viewers input present Java projects on the first level.<br>	viewer.setInput(JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()));<br>	...</font><br><br></pre>
            In addition to the Java model the <code>StandardJavaElementContentProvider</code>
            class supports the following input element types: <code>IJavaProject</code>
           , <code>IPackageFragmentRoot</code>, <code>IPackageFragment</code>
     and   <code>  IFolder</code>.<br>
<h3>Adding&nbsp; problem and override decorators</h3>
  When a viewer is to include problem annotations, then a DecoratingLabelProvider 
     together with the <a href="../reference/api/org/eclipse/jdt/ui/ProblemsLabelDecorator.html">
           ProblemsLabelDecorator</a>
   is used. Below is a code snippet that outlines the use of a &nbsp;problem
     label decorator:<br>
<pre>	<font color="#4444cc">...<br>	DecoratingLabelProvider decorator= new DecoratingLabelProvider(labelProvider, new ProblemsLabelDecorator());	<br>	viewer.setLabelProvider(decorator);<br>	...</font><br><br></pre>
           In the same way the <a href="../reference/api/org/eclipse/jdt/ui/OverrideIndicatorLabelDecorator.html">
           OverrideIndicatorLabelDecorator</a>
            can be used to decorate a normal label provider to show the implement
 and override indicators for methods.<br>
<h3>Updating the presentation on model changes</h3>
      Neither the <code>OverrideIndicatorLabelDecorator</code> nor the <code>
  ProblemsLabelDecorator</code> listen to model changes. Hence, the viewer
 doesn't update its  presentation    if the Java or resource marker model
changes. The reason for  pushing the  update onto the client for these classes
is that there isn't a generic implementation  that fulfills all performance
concerns. Handling Java model delta inspection  and viewer refreshing in
each label decorator or provider   would lead to  multiple delta inspections
and unnecessary viewer  updates.<br>
<br>
           So what does the client need to do in order to update their viewers
 ?<br>
<br>
<ul>
  <li><code>OverrideIndicatorLabelDecorator</code>: the client must listen
     to Java model changes (see <code>JavaCore.addElementChangedListener</code>
          ) and has to decide if the change(s) described by the delta invalidates
   the   override indicator of elements presented in the viewer. If so, the
 class   inspecting the delta should trigger a repaint of the corresponding
 Java elements using the standard JFace viewer API (see update methods on
StructuredViewer).</li>
  <li><code>ProblemsLabelDecorator</code>: the client should listen to  changes
   notified by the decorator via a <a href="../reference/api/org/eclipse/jdt/ui/ProblemsLabelDecorator.ProblemsLabelChangedEvent.html">
           ProblemsLabelChangedEvent</a>
            (see also <a href="../reference/api/org/eclipse/jdt/ui/ProblemsLabelDecorator.html#addListener(org.eclipse.jface.viewers.ILabelProviderListener)">
           ProblemsLabelDecorator.addListener</a>
           ). Since the marker model is resource based, the listener has
to  map   the   resource notifications to its underlying data model. For
an example    showing  how to do this for viewers presenting Java elements
see the internal    classes      <code>ProblemTreeViewer.handleLabelProviderChanged.</code></li>
</ul>
        For the same reasons enumerated for label decorators the StandardJavaElementContentProvider 
   doesn't listen to model changes. If the viewer needs to update its presentation
  according to Java model changes, then the client should add a corresponding
  listener to JavaCore. If the change described by the delta invalidates
the   structure of the elements presented in the viewer then the client should
 update the viewer using the standard JFace API (see refresh methods on StructuredViewer,
  and the add and remove methods on TableViewer and AbstractTreeViewer).
    
<p><a href="../hglegal2002.htm"><img border="0" src="../ngibmcpy2002.gif">
</a>
</p>
</body>
</html>
